# Beta_U0 BC equation:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);
C_macro3 = GET_FIELD_IF_ON_HORIZON(name);

# main function:
`#include "sns_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;
`#include "sns_XCTS_equations_lib.h"\n\n`;

`void *sns_bc_Beta_U0(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, map, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_BC_DECLARE`;
`  unsigned ijk;/* node index */`;

# declare for Cpi
Declare = 
{
 # B0 in Beta^i = B0^i+B1^i
 (obj = Field,name = B0_U0, rank = 0, C_macro);

 # B1 in Beta^i = B0^i+B1^i
 (obj = Field,name = B1_U0, rank = 0, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # eta = alpha*psi
 (obj = Field,name = eta, rank = 0, C_macro);

 # normal vector at the horizon
 (obj = Field,name = _HS_U0, rank = 0, C_macro3);

 # Cartesian x, y and z coords
 #(obj = variable,name = x,none);
 (obj = variable,name = y,none);
 (obj = variable,name = z,none);

 # BH_Omega
 #(obj = variable,name = BH_Omega_U0,none);
 #(obj = variable,name = BH_Omega_U1,none);
 (obj = variable,name = BH_Omega_U2,none);
}

# symmetries for Cpi
# no symmetry


# NOTE: write each equation in terms of ijk point, and if there is no
# outer boundary or inner boundary equation, let it be 0.

# OUTER BOUNDARY LIKE INFINITY #

`  const double C_BH = 0; #0.5*GetParameterD_E("BH_NS_separation");`;
#`  const double BH_Omega_U0 = GetParameterD_E("BH_Omega_U0");`;
#`  const double BH_Omega_U1 = GetParameterD_E("BH_Omega_U1");`;
`  const double BH_Omega_U2 = 0; #GetParameterD_E("BH_Omega_U2");`;

`  if (patch->outerB)/* at outer boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;


# bc equation for outer boundary at ijk point:
outerB_F = B0_U0;


`  F[map[ijk]] = outerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of if (patch->outerB) */`;

# INNER BOUNDARY LIKE BLACK HOLE HORIZON #
`  else if (patch->innerB)/* at inner boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;


# bc equation for inner boundary at ijk point:

alpha = eta/psi;
S_U0  = _HS_U0/(psi**2);
#` double x = patch->node[ijk]->x[0];`;
`  double y = patch->node[ijk]->x[1]-C_BH;`;
#`  double z = patch->node[ijk]->x[2];`;
#OmegaXr_U0 = BH_Omega_U1*z-BH_Omega_U2*y;
OmegaXr_U0 = -BH_Omega_U2*y;

innerB_F = B0_U0+B1_U0 - alpha*S_U0 - OmegaXr_U0;

`  F[map[ijk]] = innerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of else if (patch->innerB) */`;

`  return 0;`;
`}`;

