/*
  These C codes generated by Cpi version 1.0
  Copyright (C) 2019 Alireza Rashti.
*/


#include "sns_headers.h"
#include "maths_equation_solvings_lib.h"
#include "sns_XCTS_equations_lib.h"


void *sns_bc_eta(void *vp1,void *vp2)
{
  DDM_SCHUR_BC_DECLARE
  unsigned ijk;/* node index */

  /* declaring: */
  GET_FIELD(eta)
  GET_FIELD(psi)


  if (patch->outerB)/* at outer boundary */
  {
  DDM_SCHUR_BC_OPEN

  double outerB_F = 
eta[ijk] - 1;

  F[map[ijk]] = outerB_F;

  DDM_SCHUR_BC_CLOSE
  }/* end of if (patch->outerB) */
  else if (patch->innerB)/* at inner boundary */
  {
  const double r02   = SQR(GetParameterD_E("RollOff_distance"));
  const double M_BH  = GetParameterD_E("BH_mass");
  const double a_BH  = GetParameterD_E("BH_X_U2")*M_BH;
  const double a2_BH = SQR(a_BH);
  const double C_BH  = 0.5*GetParameterD_E("BH_NS_separation");
  DDM_SCHUR_BC_OPEN

   double x   = patch->node[ijk]->x[0];
   double y   = patch->node[ijk]->x[1]-C_BH;
   double z   = patch->node[ijk]->x[2];
   double r2  = SQR(x)+SQR(y)+SQR(z);
   double rbar2  = 0.5*(r2-a2_BH+sqrt(SQR(r2-a2_BH)+4*a2_BH*SQR(z)));
   double rbar   = sqrt(rbar2);
   double k2 = z/rbar;
   double H  = M_BH*rbar/(rbar2+a2_BH*SQR(k2));
   double C  = 2.*H;
   double KS_alpha = 1/sqrt(1+C);
   double innerB_F = 
-KS_alpha*psi[ijk]*exp(-pow(r2, 2)/pow(r02, 2)) + eta[ijk];

  F[map[ijk]] = innerB_F;

  DDM_SCHUR_BC_CLOSE
  }/* end of else if (patch->innerB) */
  return 0;
}
