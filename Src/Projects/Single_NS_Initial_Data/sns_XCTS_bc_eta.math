# eta BC equation:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);

# main function:
`#include "sns_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;
`#include "sns_XCTS_equations_lib.h"\n\n`;

`void *bc_eta(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, map, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_BC_DECLARE`;
`  unsigned ijk;/* node index */`;

# declare for Cpi
Declare = 
{

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # variables
 (obj = variable,name = r2, none);
 (obj = variable,name = r02, none);
 (obj = variable,name = KS_alpha, none);

}

# symmetries for Cpi
# no symmetry

# NOTE: write each equation in terms of ijk point, and if there is no
# outer boundary or inner boundary equation, let it be 0.

# OUTER BOUNDARY LIKE INFINITY #
`  if (patch->outerB)/* at outer boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;

# bc equation for outer boundary at ijk point:
outerB_F = eta - 1;


`  F[map[ijk]] = outerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of if (patch->outerB) */`;

# INNER BOUNDARY LIKE BLACK HOLE HORIZON #
`  else if (patch->innerB)/* at inner boundary */`;
`  {`;
`  const double r02   = SQR(GetParameterD_E("RollOff_distance"));`;
`  const double M_BH  = GetParameterD_E("BH_mass");`;
`  const double a_BH  = GetParameterD_E("BH_X_U2")*M_BH;`;
`  const double a2_BH = SQR(a_BH);`;
`  const double C_BH  = 0.5*GetParameterD_E("BH_NS_separation");`;

`  DDM_SCHUR_BC_OPEN\n`;

`   double x   = patch->node[ijk]->x[0];`;
`   double y   = patch->node[ijk]->x[1]-C_BH;`;
`   double z   = patch->node[ijk]->x[2];`;
`   double r2  = SQR(x)+SQR(y)+SQR(z);`;
`   double rbar2  = 0.5*(r2-a2_BH+sqrt(SQR(r2-a2_BH)+4*a2_BH*SQR(z)));`;
`   double rbar   = sqrt(rbar2);`;
`   double k2 = z/rbar;`;
`   double H  = M_BH*rbar/(rbar2+a2_BH*SQR(k2));`;
`   double C  = 2.*H;`;
`   double KS_alpha = 1/sqrt(1+C);`

innerB_F = eta - psi*exp(-((r2/r02)**2))*KS_alpha;

`  F[map[ijk]] = innerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of else if (patch->innerB) */`;

`  return 0;`;
`}`;

