# Christoffer symbol _Gamma compatible with _gamma

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro = GET_FIELD(name);
C_macro1 = ADD_FIELD(name);
C_macro2 = PREP_FIELD(name);

# main function:
Ccode["#include "sbh_headers.h"\n\n"];
Ccode["void sbh_free_data_Gamma(Grid_T *const grid)\n{"];
Ccode["  const unsigned np = grid->np;"];
Ccode["  unsigned p;\n"];
Ccode["  OpenMP_1d_Pragma(omp parallel for)"];
Ccode["  for(p = 0; p < np; ++p)"];
Ccode["  {"];
Ccode["    Patch_T *patch = grid->patch[p];"];
Ccode["    sbh_preparing_conformal_metric_derivatives(patch);"];

Declare = 
{
 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);
 # partial derivative of conformal metric
 (obj = Field,name = _dgamma, rank = DDD, C_macro);
 # Christoffer symbol value
 (obj = Field,name = _Gamma, rank = UDD, C_macro2);
}

# symmetries:
Symm[_gammaI(i,j)   = _gammaI(j,i)];
Symm[_dgamma(i,j,k) = _dgamma(j,i,k)];
Symm[_Gamma(i,j,k)  = _Gamma(i,k,j)];

Ccode["    unsigned nn = patch->nn;"];
Ccode["    unsigned ijk;"];
Ccode["    for(ijk = 0; ijk < nn; ++ijk)"];
Ccode["    {"];

# _Gamma calculation
GAMMA(i,-k,-l) = 1/2*_gammaI(i,-m)*(_dgamma(m,k,l)+_dgamma(m,l,k)-_dgamma(k,l,m));
Symm[GAMMA(i,j,k) = GAMMA(i,k,j)];
Cpopulate[_Gamma = GAMMA];

Ccode["    }/*end of for(ijk = 0; ijk < nn; ++ijk)*/"];
Ccode["    sbh_free_conformal_metric_derivatives(patch);"];
Ccode["  }"];
Ccode["}"]; # end of _Gamma function
