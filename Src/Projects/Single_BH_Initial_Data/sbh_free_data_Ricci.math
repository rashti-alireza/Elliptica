# _Ricci scalar

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro = GET_FIELD(name);
C_macro1 = ADD_FIELD(name);
C_macro2 = PREP_FIELD(name);

# main function:
Ccode["#include "sbh_headers.h"\n\n"];
Ccode["void sbh_free_data_Ricci(Grid_T *const grid)\n{"];
Ccode["  const unsigned np = grid->np;"];
Ccode["  unsigned p;\n"];
Ccode["  OpenMP_1d_Pragma(omp parallel for)"];
Ccode["  for(p = 0; p < np; ++p)"];
Ccode["  {"];
Ccode["    Patch_T *patch = grid->patch[p];"];

Declare = 
{
 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);
 # partial derivative of conformal metric
 (obj = Field,name = _dGamma, rank = UDDD, C_macro);
 # Christoffer symbol value
 (obj = Field,name = _Gamma, rank = UDD, C_macro);
}

# symmetries:
Symm[_gammaI(i,j)   = _gammaI(j,i)];
Symm[_dGamma(i,j,k,l) = _dGamma(i,k,j,l)];
Symm[_Gamma(i,j,k)  = _Gamma(i,k,j)];

Ccode["    unsigned nn = patch->nn;"];
Ccode["    unsigned ijk;"];
Ccode["    PREP_FIELD(_R)"];
Ccode["    for(ijk = 0; ijk < nn; ++ijk)"];
Ccode["    {"];

# Ricci scalar calculation
R = _gammaI(-a,-b)*(_dGamma(c,a,b,i)*KD(-i,-c) - _dGamma(c,a,i,b)*KD(-i,-c) + _Gamma(d,a,b)*_Gamma(c,i,j)*KD(-i,-c)*KD(-j,-d) - _Gamma(d,a,i)*_Gamma(c,b,j)*KD(-i,-c)*KD(-j,-d) );

Ccode["      _R[ijk] = R;"];
Ccode["    }/*end of for(ijk = 0; ijk < nn; ++ijk)*/"];
Ccode["  }"];
Ccode["}"]; # end of _Gamma function
