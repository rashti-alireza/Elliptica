# equation: ?

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

# C macros
C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);
C_macro3 = JACOBIAN_DERIVATIVE(name);

# C arguments
C_arg = (j_name,ijk,lmn);

# main function:
Ccode["#include "bbn_headers.h""];
Ccode["#include "bbn_XCTS_equations_lib.h"\n\n"];

Ccode["void *jacobian_eq_?(void *vp1,void *vp2)"]
Ccode["{"];
Ccode["  Patch_T *const patchCcode["  = vp1;"];
Ccode["  DDM_Schur_Complement_T *const S = vp2;"];
Ccode["  double **const B = S->B->reg->A;"];
Ccode["  double **E_Trans;"];
Ccode["  const unsigned *const node = S->inv;"];
Ccode["  const unsigned Ni = S->Oi;/* number of inner mesh nodes  */"];
Ccode["  const unsigned Nj = S->NS;/* number of inner mesh+outer-boundary nodes */"];
Ccode["  const unsigned K0 = S->NS;/* number of inner mesh+outer-boundary nodes */"];
Ccode["  const unsigned Nk = patch->nn;/* total number of nodes  */"];
Ccode["  const unsigned Ref = Nj;/* for shorhand purposes  */"];
Ccode["  unsigned i,j,k,ijk,lmn;"];

Declare = 
{
 # conformal metric
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);

 # Christoffer symbol
 (obj = Field,name = _Gamma, rank = UDD, C_macro);

 # jacobian derivative
 (obj = Field,name = df, rank = DD, C_macro3,C_arg);
 
}

# symmetries:
Symm[_gamma(i,j)   = _gamma(j,i)];
Symm[_gammaI(i,j)  = _gammaI(j,i)];
Symm[_Gamma(i,j,k) = _Gamma(i,k,j)];
Symm[df(i,j)       = df(j,i)];


Ccode["  /* fill up jacobian for alpha equation:  */"];
Ccode["  /* B part:  */"];
Ccode["  for (i = 0; i < Ni; ++i)"];
Ccode["  {"];
Ccode["    ijk = node[i];"];
Ccode["    for (j = 0; j < Nj; ++j)"];
Ccode["    {"];
Ccode["    lmn = node[j];"];
	   # calculations:
# Note: since there are two parts of calculations here and one for E_part,
# one must used different naming for definition of new variable in each
# part.
	   b_jacobian = ?

Ccode["    B[i][j] = b_jacobian;/* jacobian matrix */"];
Ccode["    }"];# end of for (j = 0; j < Nj; ++j)
Ccode["  }"];# end of for (i = 0; i < Ni; ++i)
Ccode["  /* E part:  */"];
Ccode["  if (S->NI)/* if there is any interface points then E is needed  */"];
Ccode["  {"];
Ccode["    E_Trans = S->E_Trans->reg->A;"];
Ccode["    for (k = K0; k < Nk; ++k)"];
Ccode["    {"];
Ccode["      lmn = node[k];"];
Ccode["      j = k-Ref;"];
Ccode["      for (i = 0; i < Ni; ++i)"];
Ccode["      {"];
Ccode["      ijk = node[i];"];
	     # calculations:
# Note: since there are two parts of calculations here and one for B_part,
# one must used different naming for definition of new variable in each
# part.

             e_jacobian = ?
Ccode["      E_Trans[j][i] = e_jacobian;/* jacobian matrix */"];
Ccode["      }"];# end of for (i = 0; i < Ni; ++i)
Ccode["    }"];# end of for (k = K0; k < Nk; ++k)
Ccode["  }"];# if (S->NI)

Ccode["  return 0;"];
Ccode["}"];
