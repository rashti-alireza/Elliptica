/*
  These C codes generated by Cpi version 1.0
  Copyright (C) 2019 Alireza Rashti.
*/


#include "bbn_headers.h"
#include "maths_equation_solvings_lib.h"
#include "bbn_XCTS_equations_lib.h"


void *bbn_bc_Beta_U0(void *vp1,void *vp2)
{
  DDM_SCHUR_BC_DECLARE
  unsigned ijk;/* node index */

  /* declaring: */
  READ_v(B0_U0)
  READ_v(B1_U0)
  READ_v(psi)
  READ_v(eta)
  READ_v_IF_ON_HORIZON(_HS_U0)


  const double BH_center_y = Pgetd("BH_center_y");
  const double BH_center_z = Pgetd("BH_center_z");
  const double BH_Omega_U1 = Pgetd("BH_Omega_U1");
  const double BH_Omega_U2 = Pgetd("BH_Omega_U2");
  const double v0_boost    = Pgetd("v*_boost_x");
  if (patch->outerB)/* at outer boundary */
  {
  DDM_SCHUR_BC_OPEN

  double outerB_F = 
B0_U0[ijk] - v0_boost;

  F[map[ijk]] = outerB_F;

  DDM_SCHUR_BC_CLOSE
  }/* end of if (patch->outerB) */
  else if (patch->innerB)/* at inner boundary */
  {
  DDM_SCHUR_BC_OPEN

  double alpha = 
eta[ijk]/psi[ijk];

  double S_U0 = 
_HS_U0[ijk]/pow(psi[ijk], 2);

  double y = patch->node[ijk]->x[1]-BH_center_y;
  double z = patch->node[ijk]->x[2]-BH_center_z;
  double OmegaXr_U0 = 
BH_Omega_U1*z - BH_Omega_U2*y;

  double innerB_F = 
B0_U0[ijk] + B1_U0[ijk] - OmegaXr_U0 - S_U0*alpha;

  F[map[ijk]] = innerB_F;

  DDM_SCHUR_BC_CLOSE
  }/* end of else if (patch->innerB) */
  return 0;
}
