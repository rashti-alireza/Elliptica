# calculating hamiltonian and momentum constraints first method:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = READ_v_UNUSED(name);

# main function:
Ccode["#include "bbn_headers.h"\n\n"];
Ccode["void bbn_calculate_constraints_1st(Grid_T *const grid);"];
Ccode["void bbn_calculate_constraints_1st(Grid_T *const grid)"];
`{`
`  const Uint np = grid->np;`
`  Uint p;`
``
`  OpenMP_Patch_Pragma(omp parallel for)`
`  for(p = 0; p < np; ++p)`
`  {`
`    Patch_T *patch = grid->patch[p];`
`    Uint nn = patch->nn;`
`    Uint ijk;`
``
`    if(IsItInsideBHPatch(patch))`
`       continue;`

## calculating derivatives of _gammaI:
################################
`  {`# encapsulating in a block to make them local variables.
`  /* add fields for derivative of the conformal metric */`
`  DECLARE_FIELD(_gammaI_U2U2)`
`  DECLARE_FIELD(_gammaI_U0U2)`
`  DECLARE_FIELD(_gammaI_U0U0)`
`  DECLARE_FIELD(_gammaI_U0U1)`
`  DECLARE_FIELD(_gammaI_U1U2)`
`  DECLARE_FIELD(_gammaI_U1U1)`
``
    # unused fields:
    #_dgammaI_U0U2D1,
    #_dgammaI_U1U2D0
    #_dgammaI_U1U1D0
    #_dgammaI_U1U1D2
    #_dgammaI_U0U0D1
    #_dgammaI_U0U0D2
    #_dgammaI_U2U2D1
    #_dgammaI_U0U1D2
    #_dgammaI_U2U2D0

`  ADD_FIELD(_dgammaI_U0U0D1)`
`  ADD_FIELD(_dgammaI_U0U0D0)`
`  ADD_FIELD(_dgammaI_U2U2D2)`
`  ADD_FIELD(_dgammaI_U0U0D2)`
`  ADD_FIELD(_dgammaI_U0U2D1)`
`  ADD_FIELD(_dgammaI_U1U1D0)`
`  ADD_FIELD(_dgammaI_U1U1D2)`
`  ADD_FIELD(_dgammaI_U2U2D0)`
`  ADD_FIELD(_dgammaI_U2U2D1)`
`  ADD_FIELD(_dgammaI_U0U1D0)`
`  ADD_FIELD(_dgammaI_U0U1D1)`
`  ADD_FIELD(_dgammaI_U0U1D2)`
`  ADD_FIELD(_dgammaI_U0U2D0)`
`  ADD_FIELD(_dgammaI_U1U1D1)`
`  ADD_FIELD(_dgammaI_U1U2D1)`
`  ADD_FIELD(_dgammaI_U1U2D2)`
`  ADD_FIELD(_dgammaI_U1U2D0)`
`  ADD_FIELD(_dgammaI_U0U2D2)`
``
#`  DECLARE_FIELD(_dgammaI_U0U0D1)`
`  DECLARE_FIELD(_dgammaI_U0U0D0)`
`  DECLARE_FIELD(_dgammaI_U2U2D2)`
#`  DECLARE_FIELD(_dgammaI_U0U0D2)`
#`  DECLARE_FIELD(_dgammaI_U0U2D1)`
#`  DECLARE_FIELD(_dgammaI_U1U1D0)`
#`  DECLARE_FIELD(_dgammaI_U1U1D2)`
#`  DECLARE_FIELD(_dgammaI_U2U2D0)`
#`  DECLARE_FIELD(_dgammaI_U2U2D1)`
`  DECLARE_FIELD(_dgammaI_U0U1D0)`
`  DECLARE_FIELD(_dgammaI_U0U1D1)`
#`  DECLARE_FIELD(_dgammaI_U0U1D2)`
`  DECLARE_FIELD(_dgammaI_U0U2D0)`
`  DECLARE_FIELD(_dgammaI_U1U1D1)`
`  DECLARE_FIELD(_dgammaI_U1U2D1)`
`  DECLARE_FIELD(_dgammaI_U1U2D2)`
#`  DECLARE_FIELD(_dgammaI_U1U2D0)`
`  DECLARE_FIELD(_dgammaI_U0U2D2)`
``
`  /* filling the values */`
`  _dgammaI_U0U0D0->v = Partial_Derivative(_gammaI_U0U0,"x");`
#`  _dgammaI_U0U0D1->v = Partial_Derivative(_gammaI_U0U0,"y");`
#`  _dgammaI_U0U0D2->v = Partial_Derivative(_gammaI_U0U0,"z");`
`  _dgammaI_U1U2D2->v = Partial_Derivative(_gammaI_U1U2,"z");`
#`  _dgammaI_U1U1D0->v = Partial_Derivative(_gammaI_U1U1,"x");`
`  _dgammaI_U0U1D1->v = Partial_Derivative(_gammaI_U0U1,"y");`
`  _dgammaI_U0U1D0->v = Partial_Derivative(_gammaI_U0U1,"x");`
#`  _dgammaI_U1U1D2->v = Partial_Derivative(_gammaI_U1U1,"z");`
#`  _dgammaI_U0U1D2->v = Partial_Derivative(_gammaI_U0U1,"z");`
`  _dgammaI_U0U2D2->v = Partial_Derivative(_gammaI_U0U2,"z");`
`  _dgammaI_U1U2D1->v = Partial_Derivative(_gammaI_U1U2,"y");`
`  _dgammaI_U0U2D0->v = Partial_Derivative(_gammaI_U0U2,"x");`
#`  _dgammaI_U0U2D1->v = Partial_Derivative(_gammaI_U0U2,"y");`
`  _dgammaI_U2U2D2->v = Partial_Derivative(_gammaI_U2U2,"z");`
#`  _dgammaI_U2U2D0->v = Partial_Derivative(_gammaI_U2U2,"x");`
#`  _dgammaI_U1U2D0->v = Partial_Derivative(_gammaI_U1U2,"x");`
`  _dgammaI_U1U1D1->v = Partial_Derivative(_gammaI_U1U1,"y");`
#`  _dgammaI_U2U2D1->v = Partial_Derivative(_gammaI_U2U2,"y");`
`  }`
``
`  {`# encapsulating in a block to make them local variables.
#################################
Declare = 
{
 # Hamiltonian constraint
 (obj = Field,name = ham_constraint, rank = 0, C_macro2);

 # Momentum constraints
 (obj = Field,name = mom_constraint, rank = U, C_macro2);

 # _A^{ij}
 (obj = Field,name = _A_UiUj, rank = UU, C_macro);

 # partial derivative of _A^{ij}
 (obj = Field,name = _dA_UiUj, rank = UUD, C_macro3);

 # _A^{ij}*_A_{ij}
 #(obj = Field,name = _Aij2, rank = 0, C_macro);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # conformal factor first derivative 
 (obj = Field,name = dpsi, rank = D, C_macro);

 # conformal factor second derivative 
 (obj = Field,name = ddpsi, rank = DD, C_macro);

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);

 # derivative of conformal metric inverse
 (obj = Field,name = _dgammaI, rank = UUD, C_macro3);

 # Christoffer symbol value
 (obj = Field,name = _Gamma, rank = UDD, C_macro);

 # _E
 (obj = Field,name = _E, rank = 0, C_macro);

 # conformal momentum current
 (obj = Field,name = _J, rank = U, C_macro);

 # trKij
 (obj = Field,name = K, rank = 0, C_macro);

 # dtrKij
 (obj = Field,name = dK, rank = D, C_macro);

 # Ricci
 (obj = Field,name = _R, rank = 0, C_macro);
}
# symmetries:
Symm[_A_UiUj(i,j)      = _A_UiUj(j,i)];
Symm[_dA_UiUj(i,j,l)   = _dA_UiUj(j,i,l)];
Symm[_gamma(i,j)    = _gamma(j,i)];
Symm[_gammaI(i,j)   = _gammaI(j,i)];
Symm[_dgammaI(i,j,k)   = _dgammaI(j,i,k)];
Symm[_Gamma(i,j,k)  = _Gamma(i,k,j)];
Symm[ddpsi(i,j)     = ddpsi(j,i)];

Ccode["  for(ijk = 0; ijk < nn; ++ijk)"];
Ccode["  {"];
## Calculate Hamiltonian and Momentum constraints:
#################################################################
psim4     = psi**(-4);
psim6     = psi**(-6);
J(i)      = psim6*_J(i);
E         = psim6*_E;
dLnpsi(-i)= dpsi(i)/psi;

DDpsi =  _gammaI(i,j)*ddpsi(-i,-j) \
       - _gammaI(-i,-j)*_Gamma(l,i,j)*dpsi(-l);
R     = psim4*(_R-8*DDpsi/psi);

Kbar(i,j) = psim6*_A_UiUj(i,j)+K*_gammaI(i,j)/3;
Symm[Kbar(i,j) = Kbar(j,i)];

KijKij    = Kbar(i,j)*Kbar(l,m)*_gamma(-i,-l)*_gamma(-j,-m);

#### Hamiltonian:
Ham_Constraint =  R-KijKij+K**2-16*pi*E;


c(i,j,k)  =\
2*(dLnpsi(k)*KD(i,j)+dLnpsi(j)*KD(i,k)-dLnpsi(-l)*_gammaI(i,l)*_gamma(j,k));
Symm[c(i,j,k) = c(i,k,j)];

djKj(i)     = psim4*\
(psim6*(-10*dLnpsi(-j)*_A_UiUj(i,j)+_dA_UiUj(i,j,jp)*KD(-jp,-j))\
+dK(-j)*_gammaI(i,j)/3 - 4*K*dLnpsi(-j)*_gammaI(i,j)/3 \
+K*_dgammaI(i,j,jp)*KD(-j,-jp)/3);

GammaKbar(i) = _Gamma(i,j,l)*Kbar(-l,-j)+_Gamma(j,jp,l)*Kbar(i,-l)*KD(-j,-jp);
DbarjKj(i)   = djKj(i)+GammaKbar(i)*psim4;

CKbar(i) = c(i,j,l)*Kbar(-l,-j)+c(j,jp,l)*Kbar(i,-l)*KD(-j,-jp);
Dk(i)    =  DbarjKj(i)+CKbar(i)*psim4;

#### Momentum:
Mom_constraint(i) = Dk(i)-psim4*_gammaI(i,j)*dK(-j)-8*pi*J(i);

### populate ###
Cpopulate[mom_constraint = Mom_constraint];
  `  ham_constraint[ijk] = Ham_Constraint;`

#################################################################
Ccode["  }"];
`  }`

`  DECLARE_FIELD(_dgammaI_U0U0D1)`
`  DECLARE_FIELD(_dgammaI_U0U0D0)`
`  DECLARE_FIELD(_dgammaI_U2U2D2)`
`  DECLARE_FIELD(_dgammaI_U0U0D2)`
`  DECLARE_FIELD(_dgammaI_U0U2D1)`
`  DECLARE_FIELD(_dgammaI_U1U1D0)`
`  DECLARE_FIELD(_dgammaI_U1U1D2)`
`  DECLARE_FIELD(_dgammaI_U2U2D0)`
`  DECLARE_FIELD(_dgammaI_U2U2D1)`
`  DECLARE_FIELD(_dgammaI_U0U1D0)`
`  DECLARE_FIELD(_dgammaI_U0U1D1)`
`  DECLARE_FIELD(_dgammaI_U0U1D2)`
`  DECLARE_FIELD(_dgammaI_U0U2D0)`
`  DECLARE_FIELD(_dgammaI_U1U1D1)`
`  DECLARE_FIELD(_dgammaI_U1U2D1)`
`  DECLARE_FIELD(_dgammaI_U1U2D2)`
`  DECLARE_FIELD(_dgammaI_U1U2D0)`
`  DECLARE_FIELD(_dgammaI_U0U2D2)`
``
`  REMOVE_FIELD(_dgammaI_U0U0D1)`
`  REMOVE_FIELD(_dgammaI_U0U0D0)`
`  REMOVE_FIELD(_dgammaI_U2U2D2)`
`  REMOVE_FIELD(_dgammaI_U0U0D2)`
`  REMOVE_FIELD(_dgammaI_U0U2D1)`
`  REMOVE_FIELD(_dgammaI_U1U1D0)`
`  REMOVE_FIELD(_dgammaI_U1U1D2)`
`  REMOVE_FIELD(_dgammaI_U2U2D0)`
`  REMOVE_FIELD(_dgammaI_U2U2D1)`
`  REMOVE_FIELD(_dgammaI_U0U1D0)`
`  REMOVE_FIELD(_dgammaI_U0U1D1)`
`  REMOVE_FIELD(_dgammaI_U0U1D2)`
`  REMOVE_FIELD(_dgammaI_U0U2D0)`
`  REMOVE_FIELD(_dgammaI_U1U1D1)`
`  REMOVE_FIELD(_dgammaI_U1U2D1)`
`  REMOVE_FIELD(_dgammaI_U1U2D2)`
`  REMOVE_FIELD(_dgammaI_U1U2D0)`
`  REMOVE_FIELD(_dgammaI_U0U2D2)`
`  }` # end of loop over patches
`}`
