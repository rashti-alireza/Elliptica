/*
  These C codes generated by Cpi version 2.0
  Copyright (C) 2019-2020 Alireza Rashti.
*/


#include "bbn_headers.h"
#include "maths_equation_solvings_lib.h"
#include "bbn_XCTS_equations_lib.h"


void *bbn_bc_eta(void *vp1,void *vp2)
{
  DDM_SCHUR_BC_DECLARE
  unsigned ijk;/* node index */

  /* declaring: */
  READ_v(eta)
  READ_v(psi)


  if (patch->outerB)/* at outer boundary */
  {
  DDM_SCHUR_BC_OPEN

  double outerB_F = 
eta[ijk] - 1;

  F[map[ijk]] = outerB_F;

  DDM_SCHUR_BC_CLOSE
  }/* end of if (patch->outerB) */
  else if (patch->innerB)/* at inner boundary */
  {
  const double r02   = Pow2(Pgetd("BH_KerrSchild_RollOff"));
  const double M_BH  = Pgetd("BH_irreducible_mass");
  const double a_BH  = Pgetd("BH_net_spin");
  const double BH_center_x = Pgetd("BH_center_x");
  const double BH_center_y = Pgetd("BH_center_y");
  const double BH_center_z = Pgetd("BH_center_z");
  /* populate tB tR */
  Transformation_T *tB = initialize_transformation();
  Transformation_T *tR = initialize_transformation();
  bbn_transform_populate_boost_rotation(tB,tR);
  DDM_SCHUR_BC_OPEN

  double x,y,z,r2,H,k0,k1,k2,kt;
  x = patch->node[ijk]->x[0]-BH_center_x;
  y = patch->node[ijk]->x[1]-BH_center_y;
  z = patch->node[ijk]->x[2]-BH_center_z;
  r2 = Pow2(x)+Pow2(y)+Pow2(z);
  bbn_transform_get_k_and_H_KerrSchild(x,y,z,a_BH,M_BH,tB,tR,&kt,&k0,&k1,&k2,&H);
  double C = 2.*H;
  double KS_alpha = 1/sqrt(1+C*kt*kt);

  double innerB_F = 
-KS_alpha*psi[ijk]*exp(-pow(r2, 2)/pow(r02, 2)) + eta[ijk];

  F[map[ijk]] = innerB_F;

  DDM_SCHUR_BC_CLOSE
  free_transformation(tB);
  free_transformation(tR);
  }/* end of else if (patch->innerB) */
  return 0;
}
