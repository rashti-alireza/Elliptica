/*
  These C codes generated by Cpi version 2.0
  Copyright (C) 2019-2020 Alireza Rashti.
*/


#include "bbn_headers.h"
#include "maths_linear_algebra_lib.h"

void bbn_bam_set_gauges(struct IDGauge_S *const gauge);
void bbn_bam_set_gauges(struct IDGauge_S *const gauge)
{

 Grid_T *const grid = gauge->grid;
 const char *const lapse_type = gauge->lapse_type;
 const char *const shift_type = gauge->shift_type;
 const double r_CutOff = gauge->r_CutOff;
 const double rfill    = gauge->rfill;
 const double rmin     = gauge->rmin;
 const double Mb       = gauge->Mb;
 double (*psi_punc0) 
    (const double r, const double Mb,const double r_CutOff) =
    gauge->psi_punc0;
 const Uint np = grid->np;
 Uint p;

 OpenMP_Patch_Pragma(omp parallel for)
 for (p = 0; p < np; ++p)
 {
 Patch_T *patch = grid->patch[p];

 /* declaring: */
 READ_v(bam_adm_g_D0D0)
 READ_v(bam_adm_g_D0D1)
 READ_v(bam_adm_g_D0D2)
 READ_v(bam_adm_g_D2D2)
 READ_v(bam_adm_g_D1D1)
 READ_v(bam_adm_g_D1D2)
 WRITE_v(bam_Beta_U0)
 WRITE_v(bam_Beta_U1)
 WRITE_v(bam_Beta_U2)
 WRITE_v(bam_alpha)


 Uint nn = patch->nn;
 Uint ijk;
 if (strcmp_i(lapse_type,"puncture1"))
 {
 Uint modify = IsItInsideBHPatch(patch);
 for(ijk = 0; ijk < nn; ++ijk)
 {
 double detg;
 DEF_RELATIVE_x
 DEF_RELATIVE_y
 DEF_RELATIVE_z
 DEF_RELATIVE_r
 double w = bbn_bhf_smoother(r,rfill,rmin);
 double p1_g_D2D2 = 
bam_adm_g_D2D2[ijk];

 double p1_g_D1D2 = 
bam_adm_g_D1D2[ijk];

 double p1_g_D0D2 = 
bam_adm_g_D0D2[ijk];

 double p1_g_D0D1 = 
bam_adm_g_D0D1[ijk];

 double p1_g_D0D0 = 
bam_adm_g_D0D0[ijk];

 double p1_g_D1D1 = 
bam_adm_g_D1D1[ijk];

 if (modify)
 {
 double p1_gpunc_D2D2 = 
// Not supported in C:
// psi_punc0
p1_g_D2D2*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 double p1_gpunc_D1D2 = 
p1_g_D1D2*w;

 double p1_gpunc_D1D1 = 
// Not supported in C:
// psi_punc0
p1_g_D1D1*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 double p1_gpunc_D0D2 = 
p1_g_D0D2*w;

 double p1_gpunc_D0D1 = 
p1_g_D0D1*w;

 double p1_gpunc_D0D0 = 
// Not supported in C:
// psi_punc0
p1_g_D0D0*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 detg=Matrix_Determinant_3x3_Symmetric_Var(p1_gpunc,D);
 }
 else
 {
 detg=Matrix_Determinant_3x3_Symmetric_Var(p1_g,D);
 }
 double p1_psi2 = 
pow(detg, 0.16666666666666666);


 bam_alpha[ijk] = 1/(p1_psi2);

 }
 }
 else if (strcmp_i(lapse_type,"puncture2"))
 {
 Uint modify = IsItInsideBHPatch(patch);
 for(ijk = 0; ijk < nn; ++ijk)
 {
 double detg;
 DEF_RELATIVE_x
 DEF_RELATIVE_y
 DEF_RELATIVE_z
 DEF_RELATIVE_r
 double w = bbn_bhf_smoother(r,rfill,rmin);
 double p2_g_D0D2 = 
bam_adm_g_D0D2[ijk];

 double p2_g_D0D0 = 
bam_adm_g_D0D0[ijk];

 double p2_g_D0D1 = 
bam_adm_g_D0D1[ijk];

 double p2_g_D1D1 = 
bam_adm_g_D1D1[ijk];

 double p2_g_D1D2 = 
bam_adm_g_D1D2[ijk];

 double p2_g_D2D2 = 
bam_adm_g_D2D2[ijk];

 if (modify)
 {
 double p2_gpunc_D1D2 = 
p2_g_D1D2*w;

 double p2_gpunc_D1D1 = 
// Not supported in C:
// psi_punc0
p2_g_D1D1*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 double p2_gpunc_D0D1 = 
p2_g_D0D1*w;

 double p2_gpunc_D0D2 = 
p2_g_D0D2*w;

 double p2_gpunc_D0D0 = 
// Not supported in C:
// psi_punc0
p2_g_D0D0*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 double p2_gpunc_D2D2 = 
// Not supported in C:
// psi_punc0
p2_g_D2D2*w - 1.0*(w - 1)*psi_punc0(r, Mb, r_CutOff);

 detg=Matrix_Determinant_3x3_Symmetric_Var(p2_gpunc,D);
 }
 else
 {
 detg=Matrix_Determinant_3x3_Symmetric_Var(p2_g,D);
 }
 double p2_psi4 = 
pow(detg, 0.33333333333333331);


 bam_alpha[ijk] = 1/(1+p2_psi4);

 }
 }
 else if (strcmp_i(lapse_type,"one"))
 {
 for(ijk = 0; ijk < nn; ++ijk)
 {
 bam_alpha[ijk] = 1.;
 }
 }
 else if (strcmp_i(lapse_type,"XCTS"))
 {
 ;
 }
 else
 {
 Error0(NO_OPTION);
 }
 if (strcmp_i(shift_type,"zero"))
 {
 for(ijk = 0; ijk < nn; ++ijk)
 {
 bam_Beta_U0[ijk] = 0;
 bam_Beta_U1[ijk] = 0;
 bam_Beta_U2[ijk] = 0;
 }
 }
 else if (strcmp_i(shift_type,"XCTS"))
 {
 ;
 }
 else
 {
 Error0(NO_OPTION);
 }
 }
}
