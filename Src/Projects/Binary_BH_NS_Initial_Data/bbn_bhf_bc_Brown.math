# BH-filler B.C. Brown's way

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = READ_v_IF_IN_NS(name);

# main function:
`#include "bbn_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;

`void *bbn_bhf_bc_Brown(void *vp1,void *vp2);`
`void *bbn_bhf_bc_Brown(void *vp1,void *vp2)\n{`

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, map, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_BC_DECLARE`;
`  unsigned ijk;/* node index */`;

## which field it is
`  const Solving_Man_T *const sol = patch->solving_man;`
`  const char *const fld_name     = sol->field_name[sol->cf];`
`  char bc_fld_name[100] = {'\0'};`
``
`  const double * const B = patch->pool[Ind(fld_name)]->v;`
## the bc pertinent to this field
`  sprintf(bc_fld_name,"bc_%s",fld_name);`
`  const double * const v_bc = patch->pool[Ind(bc_fld_name)]->v;`
``

# NOTE: write each equation in terms of ijk point, and if there is no
# outer boundary or inner boundary equation, let it be 0.

# OUTER BOUNDARY LIKE INFINITY #
`  if (patch->outerB)/* at outer boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;

# bc equation for outer boundary at ijk point:
`  F[map[ijk]] = B[ijk]-v_bc[ijk];\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of if (patch->outerB) */`;

# INNER BOUNDARY LIKE BLACK HOLE HORIZON #
`  else if (patch->innerB)/* at inner boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;


# bc equation for inner boundary at ijk point:
innerB_F = 0;


`  F[map[ijk]] = innerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of else if (patch->innerB) */`;

`  return 0;`;
`}`;

