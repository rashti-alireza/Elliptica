# equation: Beta_U0

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);
C_macro4 = GET_FIELD_UNUSED(name);

# main function:
`#include "bbn_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;
`#include "bbn_XCTS_equations_lib.h"\n\n`;

`void *bbn_eq_Beta_U0(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_EQ_DECLARE`;
`  unsigned ijk;/* node index */`;

# declare for Cpi:
Declare = 
{
 # _A^{ij}
 (obj = Field,name = _A_UiUj, rank = UU, C_macro4);

 # partial derivative of _A^{ij}
 (obj = Field,name = _dA_UiUj, rank = UUD, C_macro4);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # alpha*psi
 (obj = Field,name = eta, rank = 0, C_macro);
 
 # trKij first derivative
 (obj = Field,name = dK, rank = D, C_macro);

 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro4);

 # conformal connections
 (obj = Field,name = _Gamma, rank = UDD, C_macro4);

 # conformal momentum current
 (obj = Field,name = _J, rank = U, C_macro4);

}

# symmetries for Cpi:
Symm[_dA_UiUj(i,j,k) = _dA_UiUj(j,i,k)];
Symm[_A_UiUj(i,j)    = _A_UiUj(j,i)];
Symm[_gammaI(i,j)    = _gammaI(j,i)];
Symm[_Gamma(i,j,k)   = _Gamma(i,k,j)];


##########################################################################
# NOTE: In domain decomposition method n is relabed from point ijk.
# In fact ijk is mapped to point n, for relabeling purposes of
# domain decompostion which is encapsulated in macro DDM_SCHUR_EQ_OPEN.
# The bottom line is JUST simply WRITE the equation FOR F_eq 
# at Newton-Raphson scheme (Jx = -F_eq) in TERMS OF ijk POINT.
##########################################################################

`  DDM_SCHUR_EQ_OPEN\n`;

#alphabar = eta*psi**(-7);# alpha * psi^-6 => large error for psi < 1

F00(i) = psi**(-3)*(\
 _dA_UiUj(i,j,jp)*KD(-j,-jp)+\
_Gamma(i,j,l)*_A_UiUj(-l,-j)+\
_Gamma(j,jp,l)*_A_UiUj(i,-l)*KD(-j,-jp));

F0(i) = psi**(-4)*F00(i);

F1(i) = -2/3*_gammaI(i,j)*dK(-j)/psi -8*pi*(psi**-3)*_J(i);

F_eq(i) = 2*eta*(F0(i)+F1(i));

`  F[n] = F_eq_U0;\n`;# Jx = -F in Newton-Raphson scheme
`  DDM_SCHUR_EQ_CLOSE\n`;

`  return 0;`;
`}`;

# TO OPTIMIZE the function one can trim off all redunted components:
Command["sed -i -E '/^\s{2}double \w+_U[12] =/,/;$/d'"];
