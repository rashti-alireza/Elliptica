# calculating hamiltonian and momentum constraints second method:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = READ_v_UNUSED(name);

# main function:
Ccode["#include "bbn_headers.h"\n\n"];
Ccode["void bbn_calculate_constraints_2nd(Grid_T *const grid);"];
Ccode["void bbn_calculate_constraints_2nd(Grid_T *const grid)"];
`{`
``
`  bbn_make_K_UiUj_and_dK_UiUj(grid);`
`  bbn_make_metric_and_Gamma_and_derivatives(grid);`
`  const unsigned np = grid->np;`
`  unsigned p;`
``
`  OpenMP_Patch_Pragma(omp parallel for)`
`  for(p = 0; p < np; ++p)`
`  {`
`    Patch_T *patch = grid->patch[p];`
`    unsigned nn = patch->nn;`
`    unsigned ijk;`
``
`    if(IsItInsideBHPatch(patch))`
`       continue;`
``
Declare = 
{
 # Hamiltonian constraint
 (obj = Field,name = ham_constraint_2nd, rank = 0, C_macro2);

 # Momentum constraints
 (obj = Field,name = mom_constraint_2nd, rank = U, C_macro2);

 # _A^{ij}
 #(obj = Field,name = _A_UiUj, rank = UU, C_macro);

 # K^{ij}
 (obj = Field,name = K_UiUj, rank = UU, C_macro);

 # K^{ij}
 (obj = Field,name = dK_UiUj, rank = UUD, C_macro3);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # conformal factor first derivative 
 #(obj = Field,name = dpsi, rank = D, C_macro);

 # conformal factor second derivative 
 #(obj = Field,name = ddpsi, rank = DD, C_macro);

 # metric 
 (obj = Field,name = gamma, rank = DD, C_macro);

 # metric inverse
 (obj = Field,name = gammaI, rank = UU, C_macro);

 # derivative of metric inverse
 #(obj = Field,name = dgammaI, rank = UUD, C_macro3);

 # Christoffer symbol value
 (obj = Field,name = Gamma, rank = UDD, C_macro);

 # Christoffer symbol derivatives
 (obj = Field,name = dGamma, rank = UDDD, C_macro3);

 # _E
 (obj = Field,name = _E, rank = 0, C_macro);

 # conformal momentum current
 (obj = Field,name = _J, rank = U, C_macro);

 # trKij
 (obj = Field,name = K, rank = 0, C_macro);

 # dtrKij
 (obj = Field,name = dK, rank = D, C_macro);

}
# symmetries:
Symm[K_UiUj(i,j)     = K_UiUj(j,i)];
Symm[dK_UiUj(i,j,l)  = dK_UiUj(j,i,l)];
Symm[gamma(i,j)    = gamma(j,i)];
Symm[gammaI(i,j)   = gammaI(j,i)];
#Symm[dgammaI(i,j,k)   = dgammaI(j,i,k)];
Symm[Gamma(i,j,k)     = Gamma(i,k,j)];
Symm[dGamma(i,j,k,l)  = dGamma(i,k,j,l)];

`  for(ijk = 0; ijk < nn; ++ijk)`
`  {`;
## Calculate Hamiltonian and Momentum constraints:
#################################################################
psim6  = psi**(-6);
J(i)   = psim6*_J(i);
E      = psim6*_E;

Ric1(-a,-b)    =   dGamma(c,ap,bp,i)*KD(-i,-c)*KD(-ap,a)*KD(-bp,b);
Symm[Ric1(i,j) = Ric1(j,i)];

Ric2(-a,-b)    = - dGamma(c,a,i,b)*KD(-i,-c);
Symm[Ric2(i,j) = Ric2(j,i)];

Ric3(-a,-b)    =   Gamma(d,a,b)*Gamma(c,i,j)*KD(-i,-c)*KD(-j,-d);
Symm[Ric3(i,j) = Ric3(j,i)];

Ric4(-a,-b)    = - Gamma(d,a,i)*Gamma(c,b,j)*KD(-i,-c)*KD(-j,-d);
Symm[Ric4(i,j) = Ric4(j,i)];

Ric(-a,-b)     = Ric1(-a,-b)+Ric2(-a,-b)+Ric3(-a,-b)+Ric4(-a,-b);
Symm[Ric(i,j)  = Ric(j,i)];

R        = gammaI(a,b)*Ric(-a,-b);

KijKij   = K_UiUj(i,j)*K_UiUj(l,m)*gamma(-i,-l)*gamma(-j,-m);

DjKij(i) = dK_UiUj(i,j,l)*KD(-j,-l)+\
Gamma(i,j,l)*K_UiUj(-l,-j)+\
Gamma(j,jp,l)*K_UiUj(i,-l)*KD(-j,-jp);


#### Hamiltonian:
Ham_Constraint =  R-KijKij+K**2-16*pi*E;


#### Momentum:
Mom_constraint(i) = DjKij(i)-gammaI(i,j)*dK(-j)-8*pi*J(i);


### populate:
   Cpopulate[mom_constraint_2nd = Mom_constraint];
`  ham_constraint_2nd[ijk] = Ham_Constraint;`

`  }`# end of for(ijk = 0; ijk < nn; ++ijk)
`  }`# end of for(p = 0; p < np; ++p)
`  bbn_free_metric_and_Gamma_and_derivatives(grid);`
`  bbn_free_K_UiUj_and_dK_UiUj(grid);`
`}`
