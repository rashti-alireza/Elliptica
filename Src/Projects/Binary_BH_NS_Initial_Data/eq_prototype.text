# equation: ?

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);

# main function:
Ccode["#include "bbn_headers.h""];
Ccode["#include "bbn_XCTS_equations_lib.h"\n\n"];

Ccode["void *eq_?(void *vp1,void *vp2)\n{"];
Ccode["  Patch_T *const patch = vp1;"];
Ccode["  DDM_Schur_Complement_T *const S = vp2;"];
Ccode["  double *const F = S->f;"];
Ccode["  const unsigned *const node  = S->inv;/* inverse map to node */"];
Ccode["  const unsigned N = S->Oi;/* number of inner mesh nodes */"];
Ccode["  unsigned ijk;/* node */"];
Ccode["  unsigned n;"];

Declare = 
{
 # conformal metric
 (obj = Field,name = _gamma, rank = DD, C_macro);
 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);
 # Christoffer symbol
 (obj = Field,name = _Gamma, rank = UDD, C_macro);
}

# symmetries:
Symm[_gamma(i,j)   = _gamma(j,i)];
Symm[_gammaI(i,j)  = _gammaI(j,i)];
Symm[_Gamma(i,j,k) = _Gamma(i,k,j)];

Ccode["  for (n = 0; n < N; ++n)"];
Ccode["  {"];
Ccode["  ijk  = node[n];"];
# equations:

Ccode["  F[n] = F_eq;"];
Ccode["  }"];
Ccode["  return 0;"];
Ccode["}"];

