# various gauges for evolution: see definition of "struct IDGauge_S"
# for more info.

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro1 = READ_v(name);
C_macro2 = WRITE_v(name);

`#include "bbn_headers.h"`
`#include "maths_linear_algebra_lib.h"`
``
`void bbn_bam_set_gauges(struct IDGauge_S *const gauge);`
`void bbn_bam_set_gauges(struct IDGauge_S *const gauge)`
`{`
``
` Grid_T *const grid = gauge->grid;`
` const char *const lapse_type = gauge->lapse_type;`
` const char *const shift_type = gauge->shift_type;`
` const double r_CutOff = gauge->r_CutOff;`
` const double rfill    = gauge->rfill;`
` const double rmin     = gauge->rmin;`
` const double Mb       = gauge->Mb;`
` double (*psi_punc0) `
`    (const double r, const double Mb,const double r_CutOff) =`
`    gauge->psi_punc0;`
` const Uint np = grid->np;`
` Uint p;`
``
` OpenMP_Patch_Pragma(omp parallel for)`
` for (p = 0; p < np; ++p)`
` {`
` Patch_T *patch = grid->patch[p];`

Declare = 
{
  # bam adm gij
  (obj = Field,name = bam_adm_g, rank = DD, C_macro1);

  # add: bam_Beta^i
  (obj = Field,name = bam_Beta, rank = U, C_macro2);
 
  # add: bam_alpha
  (obj = Field,name = bam_alpha, rank = 0, C_macro2);

  # det adm_g
  (obj = variable,name = detg, none);

  # Mb
  (obj = variable,name = Mb, none);

  # r
  (obj = variable,name = r, none);

  # w
  (obj = variable,name = w, none);

  # r_CutOff
  (obj = variable,name = r_CutOff, none);

  # func
  (obj = function,name = psi_punc0, none);

}
# symmetries:
Symm[bam_adm_g(i,j)   = bam_adm_g(j,i)];

` Uint nn = patch->nn;`
` Uint ijk;`

## alpha = 1/bssn_psi^2
#######################
` if (strcmp_i(lapse_type,"puncture1"))`
` {`
` Uint modify = IsItInsideBHPatch(patch);`
  ` for(ijk = 0; ijk < nn; ++ijk)`
  ` {`
  ` double detg;`
  ` DEF_RELATIVE_x`
  ` DEF_RELATIVE_y`
  ` DEF_RELATIVE_z`
  ` DEF_RELATIVE_r`
  ` double w = bbn_bhf_smoother(r,rfill,rmin);`

    p1_g(-i,-j) = bam_adm_g(i,j);
    Symm[p1_g(i,j) = p1_g(j,i)];

  ` if (modify)`
  ` {`
    p1_gpunc(-i,-j) = w*p1_g(-i,-j)+(1-w)*psi_punc0(r,Mb,r_CutOff)*KD(-i,-j);
    Symm[p1_gpunc(i,j) = p1_gpunc(j,i)];

  ` detg=Matrix_Determinant_3x3_Symmetric_Var(p1_gpunc,D);`
  ` }`
  ` else`
  ` {`
  ` detg=Matrix_Determinant_3x3_Symmetric_Var(p1_g,D);`
  ` }`

    # detg = psi12
    p1_psi2   = detg**(1/6);
  ``
  ` bam_alpha[ijk] = 1/(p1_psi2);`
  ``
  ` }`
` }`


## alpha = 1/(1+bssn_psi^4)
#######################
` else if (strcmp_i(lapse_type,"puncture2"))`
` {`
` Uint modify = IsItInsideBHPatch(patch);`
  ` for(ijk = 0; ijk < nn; ++ijk)`
  ` {`
  ` double detg;`
  ` DEF_RELATIVE_x`
  ` DEF_RELATIVE_y`
  ` DEF_RELATIVE_z`
  ` DEF_RELATIVE_r`
  ` double w = bbn_bhf_smoother(r,rfill,rmin);`

    p2_g(-i,-j) = bam_adm_g(i,j);
    Symm[p2_g(i,j) = p2_g(j,i)];

  ` if (modify)`
  ` {`
    p2_gpunc(-i,-j) = w*p2_g(-i,-j)+(1-w)*psi_punc0(r,Mb,r_CutOff)*KD(-i,-j);
    Symm[p2_gpunc(i,j) = p2_gpunc(j,i)];

  ` detg=Matrix_Determinant_3x3_Symmetric_Var(p2_gpunc,D);`
  ` }`
  ` else`
  ` {`
  ` detg=Matrix_Determinant_3x3_Symmetric_Var(p2_g,D);`
  ` }`

    # detg = psi12
    p2_psi4   = detg**(1/3);
  ``
  ` bam_alpha[ijk] = 1/(1+p2_psi4);`
  ``
  ` }`
` }`

## alpha = 1
############
` else if (strcmp_i(lapse_type,"one"))`
` {`
  ` for(ijk = 0; ijk < nn; ++ijk)`
  ` {`
  ` bam_alpha[ijk] = 1.;`
  ` }`
` }`

## alpha = don't modify
############
` else if (strcmp_i(lapse_type,"XCTS"))`
` {`
` ;`
` }`

## alpha = no option
############
` else`
` {`
` Error0(NO_OPTION);`
` }`

## beta = 0
###########
` if (strcmp_i(shift_type,"zero"))`
` {`
  ` for(ijk = 0; ijk < nn; ++ijk)`
  ` {`
  ` bam_Beta_U0[ijk] = 0;`
  ` bam_Beta_U1[ijk] = 0;`
  ` bam_Beta_U2[ijk] = 0;`
  ` }`
` }`

## shift = don't modify
############
` else if (strcmp_i(shift_type,"XCTS"))`
` {`
` ;`
` }`

## shift = no option
############
` else`
` {`
` Error0(NO_OPTION);`
` }`

` }`# for (p = 0; p < np; ++p)

`}`

