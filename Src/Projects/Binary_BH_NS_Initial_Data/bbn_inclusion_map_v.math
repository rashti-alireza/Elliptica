# populate 2d metric h = dx/dy dx/dy g point by point

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ij;


`#include "bbn_headers.h"`
``

`void bbn_inclusion_map_S2_to_M_theta_phi(`
`double *const v_U0,`
`double *const v_U1,`
`double *const v_U2,`
`const double *const w_U0,`
`const double *const w_U1,`
`const double r,`
`const double theta,`
`const double phi);`
`void bbn_inclusion_map_S2_to_M_theta_phi(`
`double *const v_U0,`
`double *const v_U1,`
`double *const v_U2,`
`const double *const w_U0,`
`const double *const w_U1,`
`const double r,`
`const double theta,`
`const double phi)`
`{`
` const unsigned ij = 0;`
` const double zero = 0;`
` const double *const w_U2 = &zero;`

Declare = 
{
 # included v on M
 (obj = Field,name = v, rank = U, none);
 #  w on S2
 (obj = Field,name = w, rank = U, none);
 # inclusion matrix transformation
 (obj = Field,name = dx_dy, rank = UD, none);
}

`double dx_dy_U0D0[1],dx_dy_U0D1[1],dx_dy_U0D2[1];`
`dx_dy_U0D0[ij] = r*cos(theta)*cos(phi);`
`dx_dy_U0D1[ij] = -r*sin(theta)*sin(phi);`
`dx_dy_U0D2[ij] = 0;`


`double dx_dy_U1D0[1],dx_dy_U1D1[1],dx_dy_U1D2[1];`
`dx_dy_U1D0[ij] = r*cos(theta)*sin(phi);`
`dx_dy_U1D1[ij] = r*sin(theta)*cos(phi);`
`dx_dy_U1D2[ij] = 0;`


`double dx_dy_U2D0[1],dx_dy_U2D1[1],dx_dy_U2D2[1];`
`dx_dy_U2D0[ij] = -r*sin(theta);`
`dx_dy_U2D1[ij] = 0;`
`dx_dy_U2D2[ij] = 0;`

iv(i) = dx_dy(i,a)*w(-a);
`v_U0[ij] = iv_U0;`
`v_U1[ij] = iv_U1;`
`v_U2[ij] = iv_U2;`

`}`
