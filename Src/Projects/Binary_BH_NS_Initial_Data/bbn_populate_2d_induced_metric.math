# populate 2d metric h = dx/dy dx/dy g point by point

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ij;


`#include "bbn_headers.h"`
``

`void bbn_populate_2d_induced_metric_S2_theta_phi(`
`double *const h_D0D0,`
`double *const h_D0D1,`
`double *const h_D1D1,`
`const double *const g_D0D0,`
`const double *const g_D0D1,`
`const double *const g_D0D2,`
`const double *const g_D1D1,`
`const double *const g_D1D2,`
`const double *const g_D2D2,`
`const double theta,`
`const double phi);`
`void bbn_populate_2d_induced_metric_S2_theta_phi(`
`double *const h_D0D0,`
`double *const h_D0D1,`
`double *const h_D1D1,`
`const double *const g_D0D0,`
`const double *const g_D0D1,`
`const double *const g_D0D2,`
`const double *const g_D1D1,`
`const double *const g_D1D2,`
`const double *const g_D2D2,`
`const double r,`
`const double theta,`
`const double phi)`
`{`
`  const unsigned ij = 0;`

Declare = 
{
 # induced metric h
 (obj = Field,name = h, rank = DD, none);
 # metric
 (obj = Field,name = gamma, rank = DD, none);
 # metric transformation
 (obj = Field,name = dx_dy, rank = UD, none);
}
Symm[gamma(i,j)   = gamma(j,i)];

`dx_dy_U0D0[ij] = r*cos(theta)*cos(phi);`
`dx_dy_U0D1[ij] = -r*sin(theta)*sin(phi);`
#`dx_dy_U0D2[ij] = 0;`

`dx_dy_U1D0[ij] = r*cos(theta)*sin(phi);`
`dx_dy_U1D1[ij] = r*sin(theta)*cos(phi);`
#`dx_dy_U1D2[ij] = 0;`


`dx_dy_U0D0[ij] = 0;`
`dx_dy_U0D1[ij] = -r*sin(theta);`
#`dx_dy_U0D2[ij] = 0;`

ih(-a,-b) = dx_dy(i,a)*dx_dy(j,b)*gamma(-i,-j);
Symm[ih(a,b)   = ih(b,a))];

`h_D0D0[ij] = ih_D0D0[ij];`
`h_D0D1[ij] = ih_D0D1[ij];`
`h_D1D1[ij] = ih_D1D1[ij];`

`}`


# TO OPTIMIZE the function one can trim off all redunted components:
Command["sed -i -E '/^\s{2}double ih_D.?D2 =/,/;$/d'"];

