# populate trace of Kerr-Schild Kii 

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro = READ_v(name);
C_macro1 = ADD_FIELD(name);
C_macro2 = REALLOC_v_WRITE_v(name);

# main function:
Ccode["#include "bbn_headers.h"\n\n"];
Ccode["void bbn_free_data_KS_trKij(Patch_T *const patch)\n{"];
Ccode["  const Uint nn = patch->nn;"];
Ccode["  Uint ijk;"];

Declare = 
{
 # conformal metric inverse
 (obj = Field,name = KSgammaI, rank = UU, C_macro);

 # conncetions
 (obj = Field,name = KSGamma, rank = UDD, C_macro);

 # shift
 (obj = Field,name = KSB, rank = D, C_macro);

 # lapse
 (obj = Field,name = KSalpha, rank = 0, C_macro);

 # trKij
 (obj = Field,name = K, rank = 0, C_macro2);

 # partial derivative of shift
 (obj = Field,name = dKSB, rank = DD, C_macro);
}

# symmetries:
Symm[KSgammaI(i,j)   = KSgammaI(j,i)];
Symm[KSGamma(i,j,k)  = KSGamma(i,k,j)];

Ccode["    for(ijk = 0; ijk < nn; ++ijk)"];
Ccode["    {"];
# Curvature calculation
DB(-i,-j) = dKSB(i,j)-KSGamma(l,i,j)*KSB(-l);
Kij(-i,-j) = 0.5*(DB(i,j)+DB(j,i))/KSalpha;
Symm[Kij(i,j) = Kij(j,i)];
trK    = KSgammaI(i,j)*Kij(-i,-j);
Ccode["    K[ijk] = trK;"];

Ccode["    }/*end of for(ijk = 0; ijk < nn; ++ijk)*/"];
Ccode["}"];
