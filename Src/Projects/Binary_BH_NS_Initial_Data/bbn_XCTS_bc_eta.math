# eta BC equation:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);

# main function:
`#include "bbn_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;
`#include "bbn_XCTS_equations_lib.h"\n\n`;

`void *bbn_bc_eta(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, map, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_BC_DECLARE`;
`  unsigned ijk;/* node index */`;

# declare for Cpi
Declare = 
{

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # variables
 (obj = variable,name = r2, none);
 (obj = variable,name = r02, none);
 (obj = variable,name = KS_alpha, none);

}

# symmetries for Cpi
# no symmetry

# NOTE: write each equation in terms of ijk point, and if there is no
# outer boundary or inner boundary equation, let it be 0.

# OUTER BOUNDARY LIKE INFINITY #
`  if (patch->outerB)/* at outer boundary */`;
`  {`;
`  DDM_SCHUR_BC_OPEN\n`;

# bc equation for outer boundary at ijk point:
outerB_F = eta - 1;


`  F[map[ijk]] = outerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  }/* end of if (patch->outerB) */`;

# INNER BOUNDARY LIKE BLACK HOLE HORIZON #
`  else if (patch->innerB)/* at inner boundary */`;
`  {`;
`  const double r02   = Pow2(Pgetd("BH_KerrSchild_RollOff"));`;
`  const double M_BH  = Pgetd("BH_irreducible_mass");`;
`  const double a  = Pgetd("BH_chi_U2")*M_BH;`;
`  const double a2 = Pow2(a);`;
`  const double BH_center_x = Pgetd("BH_center_x");`
`  const double BH_center_y = Pgetd("BH_center_y");`
`  const double BH_center_z = Pgetd("BH_center_z");`
`  const double Omega_BHNS = Pgetd("BH_NS_angular_velocity");`
`  const double y_CM = Pgetd("y_CM");`
`  const double x_CM = Pgetd("x_CM");`
`  Transformation_T *t = initialize_transformation();`
`  double Bx,By,Bz;/* B = v/c */`
`  double H,kt;/* in ds^2 = (delta_ij+2*H*ki*kj)dx^i*dx^j */`
`  Bx = -Omega_BHNS*(BH_center_y-y_CM);`
`  By =  Omega_BHNS*(BH_center_x-x_CM);`
`  Bz = Pgetd("BH_Vz");`
`  t->boost->Bx = Bx;`
`  t->boost->By = By;`
`  t->boost->Bz = Bz;`
`  t->boost->B2 = Pow2(Bx)+Pow2(By)+Pow2(Bz);`

`  DDM_SCHUR_BC_OPEN\n`;

`  double x = patch->node[ijk]->x[0]-BH_center_x;`
`  double y = patch->node[ijk]->x[1]-BH_center_y;`
`  double z = patch->node[ijk]->x[2]-BH_center_z;`
`  double x_mu[4] = {0/* time component */,x,y,z};/* x^mu in boost coords */`
`  double Lm1_x_mu[4];/* Lorentz^-1 x^mu, inverse boost */`
`  t->boost->inverse = 1;`
`  boost_transformation(t,x_mu,Lm1_x_mu);`
`  double _x    = Lm1_x_mu[1];`
`  double _y    = Lm1_x_mu[2];`
`  double _z    = Lm1_x_mu[3];`
`  double rbar  = bbn_KerrShcild_r(_x,_y,_z,a);`
`  double rbar2 = Pow2(rbar);`
`  double r2    = Pow2(x)+Pow2(y)+Pow2(z);`
`  double _k0 = (rbar*_x+a*_y)/(rbar2+a2);`
`  double _k1 = (rbar*_y-a*_x)/(rbar2+a2);`
`  double _k2 = _z/rbar;`
`  double _kt = 1;`
`  double _k_mu[4] = {_kt,_k0,_k1,_k2};`
`  double L_k_mu[4];/* Lorentz *k^mu */`
`  t->boost->inverse = 0;`
`  boost_transformation(t,_k_mu,L_k_mu);`
`  kt = L_k_mu[0];`
`  H  = bbn_KerrSchild_H(M_BH,rbar,a,_z);`
`  double C = 2.*H;`
`  double KS_alpha = 1/sqrt(1+C*kt*kt);`
``
innerB_F = eta - psi*exp(-((r2/r02)**2))*KS_alpha;

`  F[map[ijk]] = innerB_F;\n`;
`  DDM_SCHUR_BC_CLOSE`;
`  free_transformation(t);`
`  }/* end of else if (patch->innerB) */`;

`  return 0;`;
`}`;

