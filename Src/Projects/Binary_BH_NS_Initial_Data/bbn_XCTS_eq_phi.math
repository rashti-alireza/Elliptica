# equation: phi, irrational piece of fluid velocity

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = GET_FIELD(name);
C_macro2 = PREP_FIELD(name);
C_macro3 = GET_FIELD_IF_IN_NS(name);

# main function:
`#include "bbn_headers.h"`;
`#include "maths_equation_solvings_lib.h"`;
`#include "bbn_XCTS_equations_lib.h"\n\n`;

`void *bbn_eq_phi(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES AND DEFINES THE FOLLOWING VARIABLES:
# patch, S, F, node, N, n.
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_EQ_DECLARE`;
`  unsigned ijk;/* node index */`;
``
`  if (!strcmp_i(GetParameterS_E("grid_kind"),"BBN_CubedSpherical_grid"))`
`    abortEr("For this grid you need to figure out where to set phi = 0.\n");`
`  `
# declare for Cpi:
Declare = 
{

 # phi
 (obj = Field,name = phi, rank = 0, C_macro3);

 # dphi 1st derivative
 (obj = Field,name = dphi, rank = D, C_macro3);

 # ddphi 2nd derivative
 (obj = Field,name = ddphi, rank = DD, C_macro3);

 # spin of NS
 (obj = Field,name = W, rank = U, C_macro3);

 # enthalpy
 (obj = Field,name = enthalpy, rank = 0, C_macro3);

 # enthalpy 1st derivative
 (obj = Field,name = denthalpy, rank = D, C_macro3);

 # rest mass density
 (obj = Field,name = rho0, rank = 0, C_macro3);

 # rest mass density 1st derivative
 (obj = Field,name = drho0, rank = D, C_macro3);

 # first component of fluid velocity
 (obj = Field,name = u0, rank = 0, C_macro3);

 # first component of fluid velocity first derivative
 (obj = Field,name = du0, rank = D, C_macro3);

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # eta first derivative 
 (obj = Field,name = deta, rank = D, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # conformal factor 1st derivative
 (obj = Field,name = dpsi, rank = D, C_macro);

 # trKij
 (obj = Field,name = K, rank = 0, C_macro);

 # shifts
 (obj = Field,name = Beta, rank = U, C_macro);

 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);

 # conformal connections
 (obj = Field,name = _Gamma, rank = UDD, C_macro);

}

# symmetries for Cpi:
Symm[_gammaI(i,j)   = _gammaI(j,i)];
Symm[_Gamma(i,j,k)  = _Gamma(i,k,j)];
Symm[ddphi(i,j)     = ddphi(j,i)];

##########################################################################
# NOTE: In domain decomposition method n is relabed from point ijk.
# In fact ijk is mapped to point n, for relabeling purposes of
# domain decompostion which is encapsulated in macro DDM_SCHUR_EQ_OPEN.
# The bottom line is JUST simply WRITE the equation FOR F_eq 
# at Newton-Raphson scheme (Jx = -F_eq) in TERMS OF ijk POINT.
##########################################################################

# NOTE, since I wanna solve phi = 0 at only one point, I need to change 
# some of the default settings.

`  if(strstr(patch->name,"left_centeral_box"))`
`  {`

`    ijk  = node[0];`;
`    F[0] = phi[ijk];`; # phi = 0
`    for (n = 1; n < N; ++n)`;
`    {`;
`      ijk  = node[n];`;

# write the equation below at ijk point:

dLn_of_alpha(i) = deta(i)/eta - dpsi(i)/psi;
#dLn_of_rho0(i)  = drho0(i)/rho0;
dLn_of_enthalpy(i)  = denthalpy(i)/enthalpy;
dLn_of_u0(i)  = du0(i)/u0;
#dLns0(i) = dLn_of_alpha(i) + dLn_of_rho0(i) - dLn_of_enthalpy(i);
#dLns1(i) = dLn_of_alpha(i) + dLn_of_rho0(i) + dLn_of_u0(i);
dLns0(i) = drho0(i)+rho0*(dLn_of_alpha(i)- dLn_of_enthalpy(i));
dLns1(i) = drho0(i)+rho0*(dLn_of_alpha(i) + dLn_of_u0(i));
alpha = eta/psi;

t1 = dLns0(-i)*((psi**-4)*_gammaI(i,l)*dphi(-l)+W(i));
t2 = (2*(psi**-5)*dpsi(-i)*_gammaI(i,l)*dphi(-l));
t3 = ((psi**-4)*_gammaI(-i,-l)*(ddphi(i,l)-_Gamma(n,i,l)*dphi(-n)));
t4 = (6*dpsi(i)*W(-i)/psi + _Gamma(i,ip,l)*W(-l)*KD(-i,-ip));
#t5 = -enthalpy*u0*(dLns1(i)*Beta(-i)+alpha*K);
t5 = -enthalpy*u0*dLns1(i)*Beta(-i);
t6 = -rho0*enthalpy*u0*alpha*K;

F_eq = t1+rho0*(t2+t3+t4)+t5+t6;

`      F[n] = F_eq;\n`;# Jx = -F in Newton-Raphson scheme
`    }`;
`  }/* left centeral box */`

`  else`
`  {`
`    DDM_SCHUR_EQ_OPEN\n`
# write the equation below at ijk point:
# I add underscore at the end of the variables to void cpi error for
# duplicated variables.

dLn_of_alpha_(i) = deta(i)/eta - dpsi(i)/psi;
#dLn_of_rho0_(i)  = drho0(i)/rho0;
dLn_of_enthalpy_(i)  = denthalpy(i)/enthalpy;
dLn_of_u0_(i)  = du0(i)/u0;
#dLns0_(i) = dLn_of_alpha_(i) + dLn_of_rho0(i) - dLn_of_enthalpy_(i);
#dLns1_(i) = dLn_of_alpha_(i) + dLn_of_rho0(i) + dLn_of_u0_(i);
dLns0_(i) = drho0(i)+rho0*(dLn_of_alpha_(i)- dLn_of_enthalpy_(i));
dLns1_(i) = drho0(i)+rho0*(dLn_of_alpha_(i) + dLn_of_u0_(i));
alpha_ = eta/psi;

t1_ = dLns0_(-i)*((psi**-4)*_gammaI(i,l)*dphi(-l)+W(i));
t2_ = (2*(psi**-5)*dpsi(-i)*_gammaI(i,l)*dphi(-l));
t3_ = ((psi**-4)*_gammaI(-i,-l)*(ddphi(i,l)-_Gamma(n,i,l)*dphi(-n)));
t4_ = (6*dpsi(i)*W(-i)/psi + _Gamma(i,ip,l)*W(-l)*KD(-i,-ip));
#t5_ = -enthalpy*u0*(dLns1_(i)*Beta(-i)+alpha_*K);
t5_ = -enthalpy*u0*dLns1_(i)*Beta(-i);
t6_ = -rho0*enthalpy*u0*alpha_*K;

F_eq_ = t1_+rho0*(t2_+t3_+t4_)+t5_+t6_;

`    F[n] = F_eq_;\n`;# Jx = -F in Newton-Raphson scheme
`    DDM_SCHUR_EQ_CLOSE\n`
`  }/* other patches of NS */`;
`  return 0;`;
`}`;

