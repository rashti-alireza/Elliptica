# forece balance eqution for root finder

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro = GET_FIELD(name);

`#include "bbn_headers.h"`
``
`double force_balance_Omega_root_finder_eq(void *params,const double *const x);`
`double force_balance_Omega_root_finder_eq(void *params,const double *const x)`
`{`
`const struct Force_Balance_RootFinder_S *const par = params;`
`Patch_T *const patch = par->patch;`
`const unsigned  nn   = patch->nn;`
`const double Omega_BHNS = x[0];`
`const double Vr         = par->Vr;`
`const double D          = par->D;`
`const double y_CM       = par->y_CM;`
`const double *const X   = par->X; `
`const double dyLnGamma  = par->dyLnGamma;`
`unsigned ijk;`  

`/* B^1 */`
`PREP_FIELD(B1_U0)`
`PREP_FIELD(B1_U1)`
`PREP_FIELD(B1_U2)`
`for (ijk = 0; ijk < nn; ++ijk)`
`{`
  `double x0  = patch->node[ijk]->x[0];`
  `double y0  = patch->node[ijk]->x[1];`
  
  `B1_U0[ijk] = Omega_BHNS*(-y0+y_CM)+Vr*x0/D;`
  `B1_U1[ijk] = Omega_BHNS*x0+Vr*(y0-y_CM)/D;`
  `B1_U2[ijk] = 0;`
`}`

`bbn_update_Beta_U0(patch);`
`bbn_update_Beta_U1(patch);`
`bbn_update_Beta_U2(patch);`

Declare = 
{

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # spin part of fluid
 (obj = Field,name = W, rank = U, C_macro);

 # d(phi)/d? for irrotional part of fluid
 #(obj = Field,name = dphi, rank = D, C_macro);

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # Beta
 (obj = Field,name = Beta, rank = U, C_macro);

 # Killing vector xi^i, assumed 0
 #(obj = Field,name = xi, rank = U, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # enthalpy
 (obj = Field,name = enthalpy, rank = 0, C_macro);

 # u^0
 (obj = Field,name = u0, rank = 0, C_macro);

}
# symmetries:
Symm[_gamma(i,j)   = _gamma(j,i)];

# rf for root finding
`ADD_FIELD(Gtilda_rf);`
`ADD_FIELD_NoMem(dGtilda_D1_rf);`

`DECLARE_FIELD(Gtilda_rf);`
`DECLARE_FIELD(dGtilda_D1_rf);`

# calculating Gamma tilda represented by Gtilda
`for (ijk = 0; ijk < nn; ++ijk)`
`{`
    alpha  = eta/psi;
    alpha2 = alpha**2;
    psi4   = psi**4;
    t(i)   = Beta(i)+W(i)/(enthalpy*u0);
    t2     = psi4*t(-i)*t(-j)*_gamma(i,j);
    Gtilda = alpha2-t2;
    ``
    `Gtilda_rf->v[ijk] = Gtilda;`
`}`

`dGtilda_D1_rf->v = Partial_Derivative(Gtilda_rf,"y");`

`Interpolation_T *interp_Gtilda  = init_interpolation();`
`Interpolation_T *interp_dGtilda = init_interpolation();`
``
`interp_Gtilda->field  = Gtilda_rf;`
`interp_dGtilda->field = dGtilda_D1_rf;`
``
`interp_Gtilda->X = X[0];`
`interp_Gtilda->Y = X[1];`
`interp_Gtilda->Z = X[2];`
`interp_Gtilda->XYZ_dir_flag = 1;`
``
`interp_dGtilda->X = X[0];`
`interp_dGtilda->Y = X[1];`
`interp_dGtilda->Z = X[2];`
`interp_dGtilda->XYZ_dir_flag = 1;`
``
`plan_interpolation(interp_Gtilda);`
`plan_interpolation(interp_dGtilda);`
`const double gt  = execute_interpolation(interp_Gtilda);`
`const double dgt = execute_interpolation(interp_dGtilda);`
``
`free_interpolation(interp_Gtilda);`
`free_interpolation(interp_dGtilda);`
``
`const double f = dgt/gt+2*dyLnGamma;`
`assert(isfinite(f));` # if f goes banana
``
`REMOVE_FIELD(Gtilda_rf);`
`REMOVE_FIELD(dGtilda_D1_rf);`

`return f;`
`}`
