# populating spin integrand using Killing vector.
# but the Killing vector for now is adopted from Camapanelli: gr-qc/0612076v4

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = add_and_get_field(name);
C_macro3 = declare_and_alloc_xi(name);

`#include "core_lib.h"`
`#include "physics_observables_lib.h"`
`#include "utilities_lib.h"`
`#include "manifold_lib.h"`
`#include "maths_general_lib.h"`
`#include "maths_calculus_lib.h"`
`#include "fields_lib.h"`
`#include "bbn_headers.h"`
``
`#define declare_and_alloc_xi(name) \`
	`  double *name = alloc_double(nn);`
``
`#define add_and_get_field(name) \`
         `  if (_Ind(#name) >= 0)\`# means if it exists already
         `  {DECLARE_FIELD(name);REMOVE_FIELD(name);}\`
         `  ADD_FIELD(name);REALLOC_v_WRITE_v(name);`
``
``
`void bbn_populate_spin_integrands_Campanelli(Patch_T *const patch,const double xc[3],const double *const normal[3]);`
`void bbn_populate_spin_integrands_Campanelli(Patch_T *const patch,const double xc[3],const double *const normal[3])`
`{`
`  const double x_c = xc[0];`
`  const double y_c = xc[1];`
`  const double z_c = xc[2];`
`  const unsigned nn = patch->nn;`
`  unsigned ijk;`

Declare = 
{
  # _A^{ij}
 (obj = Field,name = _A_UiUj, rank = UU, C_macro);

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # trKij
 #(obj = Field,name = K, rank = 0, C_macro);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # normal vector components
 (obj = Field,name = n, rank = U, none);

 # integrand xiP
 (obj = Field,name = SPIN_integrand, rank = D, C_macro2);

 # xi0
 (obj = Field,name = xi0, rank = U, C_macro3);
 # xi1
 (obj = Field,name = xi1, rank = U, C_macro3);
 # xi2
 (obj = Field,name = xi2, rank = U, C_macro3);

}
# symmetries:
Symm[_A_UiUj(i,j)  = _A_UiUj(j,i)];
#Symm[_gammaI(i,j)  = _gammaI(j,i)];
Symm[_gamma(i,j)   = _gamma(j,i)];
#Symm[_Gamma(i,j,k) = _Gamma(i,k,j)];

``
`   for(ijk = 0; ijk < nn; ++ijk)`
`   {`
`   double x    = patch->node[ijk]->x[0];`
`   double y    = patch->node[ijk]->x[1];`
`   double z    = patch->node[ijk]->x[2];`

`   xi0_U0[ijk] = 0;`
`   xi0_U1[ijk] = -(z-z_c);`
`   xi0_U2[ijk] = y-y_c;`

`   xi1_U0[ijk] = z-z_c;`
`   xi1_U1[ijk] = 0;`
`   xi1_U2[ijk] = -(x-x_c);`

`   xi2_U0[ijk] = -(y-y_c);`
`   xi2_U1[ijk] = (x-x_c);`
`   xi2_U2[ijk] = 0;`
`   }`
# populating the integrands:
`   const double *const n_U0 = normal[0];`
`   const double *const n_U1 = normal[1];`
`   const double *const n_U2 = normal[2];`

`   for (ijk = 0; ijk < nn; ++ijk)`
`   {`
    # note K^ij ~ psi^(-10)_A^{ij} but there is two gamma multiplication
    # in which gamma ~ psi^4 => psi^(-2)
    psim2 = psi**(-2);
    Pn(i) = _A_UiUj(i,j)*_gamma(-j,-k)*n(k);
    xi0P = psim2*_gamma(-i,-j)*xi0(i)*Pn(j);
    xi1P = psim2*_gamma(-i,-j)*xi1(i)*Pn(j);
    xi2P = psim2*_gamma(-i,-j)*xi2(i)*Pn(j);

`   SPIN_integrand_D0[ijk] = xi0P;`
`   SPIN_integrand_D1[ijk] = xi1P;`
`   SPIN_integrand_D2[ijk] = xi2P;`
`   }`
``
`   free(xi0_U0);`
`   free(xi0_U1);`
`   free(xi0_U2);`

`   free(xi1_U0);`
`   free(xi1_U1);`
`   free(xi1_U2);`

`   free(xi2_U0);`
`   free(xi2_U1);`
`   free(xi2_U2);`
``
`}`
