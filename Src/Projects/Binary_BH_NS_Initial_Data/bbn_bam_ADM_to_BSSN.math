# deriving bssn variables from adm variables:
# bssn_init.m in Bam says: (bar(b) variables := adm and tilda (t) := bssn)

# 
#  (* conformal factors *)
#  detgb       == matrixdet[gb],
#  psim4       == detgb^(-1/3),
#  psi         == detgb^(1/12),
#
#  (* basic rescaling *)
#  gt[a,b]     == psim4 gb[a,b],
#  Kt[a,b]     == psim4 Kb[a,b], 
#
#  (* inverse bssn metric *)
#  detgt       == matrixdet[gt],
#  detgtinv    == 1/detgt,
#  gtinv[a,b]  == detgtinv matrixinvdet[gt,a,b],
# 
#  (* additional variables *)
#  K           == gtinv[a,b] Kt[a,b],
#  A[a,b]      == Kb[a,b] - gb[a,b] K / 3,
#  At[a,b]     == psim4 A[a,b],
#  chi         == Power[psi,chipsipower],

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro1  = READ_v(name);
C_macro2 = add_field_and_prep_field(name);

`#include "bbn_headers.h"`
`#include "maths_linear_algebra_lib.h"`
``
`#define add_field_and_prep_field(name) \`
` if (_Ind(#name) < 0) {ADD_FIELD(name)} REALLOC_v_WRITE_v(name)`

`void bbn_bam_adm_to_bssn(Patch_T *const patch);`
`void bbn_bam_adm_to_bssn(Patch_T *const patch)`
`{`


Declare = 
{
  # bam adm gij
  (obj = Field,name = bam_adm_g, rank = DD, C_macro1);

  # bam adm Kij
  (obj = Field,name = bam_adm_K, rank = DD, C_macro1);

  # bam bssn gij
  (obj = Field,name = bam_bssn_g, rank = DD, C_macro2);

   # bam bssn gij inverse
  (obj = Field,name = bam_bssn_gI, rank = UU, C_macro2);

  # bam bssn Aij
  (obj = Field,name = bam_bssn_A, rank = DD, C_macro2);

  # bam bssn psi
  (obj = Field,name = bam_bssn_psi, rank = 0, C_macro2);

  # bam bssn chi
  (obj = Field,name = bam_bssn_chi, rank = 0, C_macro2);

  # bam bssn K
  (obj = Field,name = bam_bssn_K, rank = 0, C_macro2);

  # detgb
  (obj = variable,name = detgb, none);

}
# symmetries:
Symm[bam_adm_g(i,j)   = bam_adm_g(j,i)];
Symm[bam_adm_K(i,j)   = bam_adm_K(j,i)];
Symm[bam_bssn_g(i,j)  = bam_bssn_g(j,i)];
Symm[bam_bssn_gI(i,j) = bam_bssn_gI(j,i)];
Symm[bam_bssn_A(i,j)  = bam_bssn_A(j,i)];

` unsigned nn = patch->nn;`
` unsigned ijk;`
` for(ijk = 0; ijk < nn; ++ijk)`
` {`

  ## conformal factors:
  ` double detgb;`
  ` Determinant_Matrix_3x3_Symmetric_Field(bam_adm_g,D,ijk,detgb);`
  ``
  psi12 = detgb;
  psi   = psi12**(1/12);
  psim4 = psi12**(-1/3);

  ## basic rescaling:
  bssn_g(-i,-j) = psim4 * bam_adm_g(i,j);
  Symm[bssn_g(i,j) = bssn_g(j,i)];
  Kt(i,j)     = psim4 * bam_adm_K(i,j);
  Symm[Kt(i,j) = Kt(j,i)];
  
  ## inverse bssn metric:
  ## init variables
  bssn_gI(i,j) = KD(i,j);
  Symm[bssn_gI(i,j) = bssn_gI(j,i)];
  ## now populate the matrix
  ` Matrix_Inverse_3x3_Symmetric_Var(bssn_g,D,bssn_gI,U);`

  ## additional variables:
  K =  bam_bssn_gI(i,j)*Kt(-i,-j);
  A(-i,-j)    = bam_adm_K(i,j)-bam_adm_g(i,j)*K/3;
  symm[A(i,j) = A(j,i)];
  bssn_A(-i,-j)    = psim4 *A(i,j);
  symm[bssn_A(i,j) = bssn_A(j,i)];
  
  ## populate
  Cpopulate[bam_bssn_A  = bssn_A];
  Cpopulate[bam_bssn_g  = bssn_g];
  Cpopulate[bam_bssn_gI = bssn_gI];
  ` bam_bssn_chi[ijk] = psim4;`;
  ` bam_bssn_psi[ijk] = psi;`;
  ` bam_bssn_K[ijk]   = K;`;
 
` }`


`}`

