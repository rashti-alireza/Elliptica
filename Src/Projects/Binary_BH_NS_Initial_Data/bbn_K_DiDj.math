# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = add_field_and_prep_field(name);

# main function:
Ccode["#include "bbn_headers.h"\n\n"];
`#define add_field_and_prep_field(name) \`
` if (_Ind(#name) < 0) {ADD_FIELD(name)} REALLOC_v_WRITE_v(name)`
``
`void bbn_adm_Kij(Patch_T *const patch);`
`void bbn_adm_Kij(Patch_T *const patch)`
`{`
Declare = 
{
 # K_{ij}
 (obj = Field,name = K_DiDj, rank = DD, C_macro2);

 # shift
 (obj = Field,name = Beta, rank = U, C_macro);

 # d(shift)/d?
 (obj = Field,name = dBeta, rank = UD, C_macro);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # eta
 (obj = Field,name = K, rank = 0, C_macro);

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # Christoffer symbol value
 (obj = Field,name = _Gamma, rank = UDD, C_macro);

}

# symmetries:
Symm[_gamma(i,j)    = _gamma(j,i)];
Symm[_Gamma(i,j,k)  = _Gamma(i,k,j)];
Symm[K_DiDj(i,j)    = K_DiDj(j,i)];

Ccode["    unsigned nn = patch->nn;"];
Ccode["    unsigned ijk;"];
Ccode["    for(ijk = 0; ijk < nn; ++ijk)"];
Ccode["    {"];

# calculating K_{ij}:
  psi4 = psi**4;
  _DB_UD(i,-j)     = (dBeta(i,j)+_Gamma(i,j,m)*Beta(-m));# _D_{j}B^{i}
  _LV_DD(-i,-j)    = _gamma(i,-l)*_DB_UD(l,j)+_gamma(j,-m)*_DB_UD(m,i)-2/3*_gamma(i,j)*_DB_UD(m,-m);
  Symm[_LV_DD(i,j) = _LV_DD(j,i)];

  K_DDij(-i,-j)    = psi4*(psi*_LV_DD(i,j)/(2*eta)+1/3*K*_gamma(i,j));
  Symm[K_DDij(i,j) = K_DDij(j,i)];
  Cpopulate[K_DiDj = K_DDij];

Ccode["    }/*end of for(ijk = 0; ijk < nn; ++ijk)*/"];

`}`

