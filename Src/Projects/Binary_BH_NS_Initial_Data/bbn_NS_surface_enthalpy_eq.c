/*
  These C codes generated by Cpi version 1.0
  Copyright (C) 2019 Alireza Rashti.
*/


#include "bbn_headers.h"
#define define_variable(xNAME) \
  Field_T *const field_##xNAME = patch->pool[Ind(#xNAME)]; \
  Interpolation_T *interp_##xNAME = init_interpolation(); \
  interp_##xNAME->field = field_##xNAME; \
  interp_##xNAME->XYZ_dir_flag = 1; \
  interp_##xNAME->X = X[0]; \
  interp_##xNAME->Y = X[1]; \
  interp_##xNAME->Z = X[2]; \
  plan_interpolation(interp_##xNAME); \
  const double xNAME = execute_interpolation(interp_##xNAME); \
  free_interpolation(interp_##xNAME);

double bbn_NS_surface_enthalpy_eq(void *params,const double *const x);
double bbn_NS_surface_enthalpy_eq(void *params,const double *const x)
{
  /* the stucture for the root finder */
  const struct NS_surface_RootFinder_S *const pars = params;
  const double dx = x[0]*pars->scale;
  Patch_T *const patch   = pars->patch;
  const double *const x0 = pars->x0;
  const double *const N  = pars->N;
  const double Euler_C   = pars->Euler_C;
  const double y[3]      = {x0[0]+dx*N[0],x0[1]+dx*N[1],x0[2]+dx*N[2]};
  double X[3];

  X_of_x(X,y,patch);

  /* declaring: */
  define_variable(_gamma_D2D2)
  define_variable(_gamma_D0D2)
  define_variable(_gamma_D0D0)
  define_variable(_gamma_D0D1)
  define_variable(_gamma_D1D2)
  define_variable(_gamma_D1D1)
  define_variable(_gammaI_U0U2)
  define_variable(_gammaI_U0U0)
  define_variable(_gammaI_U0U1)
  define_variable(_gammaI_U1U2)
  define_variable(_gammaI_U1U1)
  define_variable(_gammaI_U2U2)
  define_variable(W_U1)
  define_variable(W_U0)
  define_variable(W_U2)
  define_variable(dphi_D2)
  define_variable(dphi_D1)
  define_variable(dphi_D0)
  define_variable(eta)
  define_variable(Beta_U1)
  define_variable(Beta_U0)
  define_variable(Beta_U2)
  define_variable(psi)


  double alpha = 
eta/psi;

  double psim4 = 
pow(psi, -4);

  double psi4 = 
pow(psi, 4);

  double P2 = 
2.0*W_U0*dphi_D0 + 2.0*W_U1*dphi_D1 + 2.0*W_U2*dphi_D2 + psi4*
(pow(W_U0, 2)*_gamma_D0D0 + 2.0*W_U0*W_U1*_gamma_D0D1 + 2.0*W_U0*W_U2*
_gamma_D0D2 + pow(W_U1, 2)*_gamma_D1D1 + 2.0*W_U1*W_U2*_gamma_D1D2 +
pow(W_U2, 2)*_gamma_D2D2) + psim4*(_gammaI_U0U0*pow(dphi_D0, 2) + 2.0*
_gammaI_U0U1*dphi_D0*dphi_D1 + 2.0*_gammaI_U0U2*dphi_D0*dphi_D2 +
_gammaI_U1U1*pow(dphi_D1, 2) + 2.0*_gammaI_U1U2*dphi_D1*dphi_D2 +
_gammaI_U2U2*pow(dphi_D2, 2));

  double uW = 
W_U0*dphi_D0 + W_U1*dphi_D1 + W_U2*dphi_D2 + psi4*(pow(W_U0, 2)*
_gamma_D0D0 + 2.0*W_U0*W_U1*_gamma_D0D1 + 2.0*W_U0*W_U2*_gamma_D0D2 +
pow(W_U1, 2)*_gamma_D1D1 + 2.0*W_U1*W_U2*_gamma_D1D2 + pow(W_U2, 2)*
_gamma_D2D2);

  double Bdphi = 
Beta_U0*dphi_D0 + Beta_U1*dphi_D1 + Beta_U2*dphi_D2;

  double b = 
2*pow(alpha, 2)*uW + pow(Bdphi - Euler_C, 2);

  double L2 = 
(1.0/2.0)*(b + sqrt(-4*pow(alpha, 4)*pow(uW, 2) + pow(b, 2)))/
pow(alpha, 2);

  double h2 = 
L2 - P2;

  double h = 
sqrt(h2);

  return h-1;
}
