# adding bam fields into grid and compute them, 
# the fields are as follows:
# bam_alpha,bam_Beta^i,bam_adm_g_ij,bam_adm_K_ij,bam_grhd_v^i

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = DECLARE_AND_EMPTY_FIELD(name);
C_macro4 = add_field_and_alloc_field(name);

# main function:
`#include "bbn_headers.h"`
``
`#define add_field_and_alloc_field(name) ADD_FIELD(name) REALLOC_v_WRITE_v(name)`
``
`void bbn_extrinsic_K_DiDj(Patch_T *const patch);`
`void bbn_bam_set_bam_fields(Grid_T *const grid);`
`void bbn_bam_set_bam_fields(Grid_T *const grid)`
`{`
`  unsigned p;`
`  const unsigned np = grid->np;`
``
`  OpenMP_Patch_Pragma(omp parallel for)`
`  for (p = 0; p < np; ++p)`
`  {`
`  Patch_T *patch = grid->patch[p];`
`  unsigned nn    = patch->nn;`
`  unsigned ijk;`
`  if (!IsItInsideBHPatch(patch))`
`    bbn_extrinsic_K_DiDj(patch);`
``
Declare = 
{
 # add: bam_alpha
 (obj = Field,name = bam_alpha, rank = 0, C_macro4);

 # add: bam_grhd_rho
 (obj = Field,name = bam_grhd_rho, rank = 0, C_macro4);

 # add: bam_grhd_p
 (obj = Field,name = bam_grhd_p, rank = 0, C_macro4);

 # add: bam_grhd_epsl
 (obj = Field,name = bam_grhd_epsl, rank = 0, C_macro4);

 # add: bam_Beta^i
 (obj = Field,name = bam_Beta, rank = U, C_macro4);

 # add: bam_adm_g_ij
 (obj = Field,name = bam_adm_g, rank = DD, C_macro4);

 # add: bam_adm_K_ij
 (obj = Field,name = bam_adm_K, rank = DD, C_macro4);

 # add: bam_grhd_v^i
 (obj = Field,name = bam_grhd_v, rank = U, C_macro4);

 # add: bam_chi = psi^-4
 (obj = Field,name = bam_chi, rank = 0, C_macro4);

 # K_{ij}
 (obj = Field,name = K_DiDj, rank = DD, C_macro);

 # shift
 (obj = Field,name = Beta, rank = U, C_macro);

 # B1 in Beta = B0+B1
 #(obj = Field,name = B1, rank = U, C_macro);

 # psi
 (obj = Field,name = psi, rank = 0, C_macro);

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # trKij
# (obj = Field,name = K, rank = 0, C_macro);

 # enthalpy
 (obj = Field,name = enthalpy, rank = 0, C_macro);

 # spin part of fluid
 (obj = Field,name = W, rank = U, C_macro);

 # d(phi)/d? for irrotional part of fluid
 (obj = Field,name = dphi, rank = D, C_macro);

 # u0
 (obj = Field,name = u0, rank = 0, C_macro);

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # conformal metric inverse
 (obj = Field,name = _gammaI, rank = UU, C_macro);
}

# symmetries:
Symm[K_DiDj(i,j)   = K_DiDj(j,i)];
Symm[bam_adm_K(i,j) = bam_adm_K(j,i)];
Symm[bam_adm_g(i,j) = bam_adm_g(j,i)];
Symm[_gamma(i,j)    = _gamma(j,i)];
Symm[_gammaI(i,j)   = _gammaI(j,i)];

`  for(ijk = 0; ijk < nn; ++ijk)`
`  {`
   psi4   = psi**4;

# alpha:
`   bam_alpha[ijk] = eta[ijk]/psi[ijk];`

# beta:
`   bam_Beta_U0[ijk] = Beta_U0[ijk];`
`   bam_Beta_U1[ijk] = Beta_U1[ijk];`
`   bam_Beta_U2[ijk] = Beta_U2[ijk];`

# g_ij:
   adm_g(-i,-j) = psi4*_gamma(i,j);
   Symm[adm_g(i,j) = adm_g(j,i)];
   Cpopulate[bam_adm_g = adm_g];

# K_ij:
   Kdd(-i,-j) = K_DiDj(i,j);
   Symm[Kdd(i,j) = Kdd(j,i)];
   Cpopulate[bam_adm_K = Kdd];

# bam_chi (for test purposes)
`   bam_chi[ijk] = 1/psi4;`

`  }`# end of for(ijk = 0; ijk < nn; ++ijk)

# otherwise grhd_v^i and metter fields set zero by calloc
`  if (IsItNSPatch(patch))`
`  {`
`  EoS_T *eos = initialize_EoS();`
`  for(ijk = 0; ijk < nn; ++ijk)`
`  {`

   # grhd_v^i:
   psim4 = psi**(-4);
   grhd_v(i) = (psim4*_gammaI(i,j)*dphi(-j)+W(i))/(bam_alpha*enthalpy*u0);
   Cpopulate[bam_grhd_v = grhd_v];
``
   # matter: total_energy_density = grhd_rho(1+grhd_epsl)
`  eos->h = enthalpy[ijk];`
`  if(!isfinite(eos->h) || LSSEQL(eos->h,1))`
`  {`
`    bam_grhd_rho[ijk]  = 0;`
`    bam_grhd_p[ijk]    = 0;`
`    bam_grhd_epsl[ijk] = 0;`
`  }`
`  else`
`  {`
`   bam_grhd_rho[ijk]  = eos->rest_mass_density(eos);`
`   bam_grhd_p[ijk]    = eos->pressure(eos);`
`   bam_grhd_epsl[ijk] = eos->energy_density(eos)/bam_grhd_rho[ijk]-1.0;`
`  }`
`  }`# end of for(ijk = 0; ijk < nn; ++ijk)
`  free_EoS(eos);`
`  }`# end of if (IsItNSPatch(patch))
`  }`# end of FOR_ALL_PATCHES


`}` # end of function
