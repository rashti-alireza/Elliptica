# forece balance eqution for root finder

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

C_macro = READ_v(name);

`#include "bbn_headers.h"`
``
`double force_balance_root_finder_eq(void *params,const double *const x);`
`double force_balance_root_finder_eq(void *params,const double *const x)`
`{`
`const struct Force_Balance_RootFinder_S *const par = params;`
`Patch_T *const patch = par->patch;`
`const unsigned  nn   = patch->nn;`
`const double *const X = par->X; `
`const double dLnGamma = par->dLnGamma;`
`const int dir         = par->dir;`
`const double Vr       = par->Vr;`
`const double D        = par->D;`
`double Omega_BHNS,y_CM,x_CM;`
`unsigned ijk;`  
``
`if(par->find_y_CM)`
`{`
`  Omega_BHNS = par->Omega_BHNS;`
`  y_CM       = x[0];`
`  x_CM       = par->x_CM;`
`}`
`else if(par->find_x_CM)`
`{`
`  Omega_BHNS = par->Omega_BHNS;`
`  y_CM       = par->y_CM;`
`  x_CM       = x[0];`
`}`
`else if(par->find_Omega)`
`{`
`  Omega_BHNS = x[0];`
`  y_CM       = par->y_CM;`
`  x_CM       = par->x_CM;`
`}`
`else`
`  abortEr(NO_OPTION);`
``
`/* B^1 */`
`REALLOC_v_WRITE_v(B1_U0)`
`REALLOC_v_WRITE_v(B1_U1)`
`REALLOC_v_WRITE_v(B1_U2)`
`for (ijk = 0; ijk < nn; ++ijk)`
`{`
  `double x0     = patch->node[ijk]->x[0];`
  `double y0     = patch->node[ijk]->x[1];`
  
  `B1_U0[ijk] = Omega_BHNS*(-y0+y_CM)+Vr*(x0-x_CM)/D;`
  `B1_U1[ijk] = Omega_BHNS*(x0-x_CM)+Vr*(y0-y_CM)/D;`
  `B1_U2[ijk] = 0;`
`}`

`bbn_update_Beta_U0(patch);`
`bbn_update_Beta_U1(patch);`
`bbn_update_Beta_U2(patch);`

Declare = 
{

 # conformal metric 
 (obj = Field,name = _gamma, rank = DD, C_macro);

 # spin part of fluid
 (obj = Field,name = W, rank = U, C_macro);

 # d(phi)/d? for irrotional part of fluid
 #(obj = Field,name = dphi, rank = D, C_macro);

 # eta
 (obj = Field,name = eta, rank = 0, C_macro);

 # Beta
 (obj = Field,name = Beta, rank = U, C_macro);

 # Killing vector xi^i, assumed 0
 #(obj = Field,name = xi, rank = U, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # enthalpy
 (obj = Field,name = enthalpy, rank = 0, C_macro);

 # u^0
 (obj = Field,name = u0, rank = 0, C_macro);

}
# symmetries:
Symm[_gamma(i,j)   = _gamma(j,i)];

# rf for root finding
`ADD_AND_ALLOC_FIELD(Gtilda_rf);`
`ADD_FIELD(dGtilda_rf);`

`DECLARE_FIELD(Gtilda_rf);`
`DECLARE_FIELD(dGtilda_rf);`

# calculating Gamma tilda represented by Gtilda
`for (ijk = 0; ijk < nn; ++ijk)`
`{`
    alpha  = eta/psi;
    alpha2 = alpha**2;
    psi4   = psi**4;
    t(i)   = Beta(i)+W(i)/(enthalpy*u0);
    t2     = psi4*t(-i)*t(-j)*_gamma(i,j);
    Gtilda = alpha2-t2;
    ``
    `Gtilda_rf->v[ijk] = Gtilda;`
`}`
``
`if (dir == 0)`
`  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"x");`
`else if (dir == 1)`
`  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"y");`
`else if (dir == 2)`
`  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"z");`
`else`
`  abortEr(NO_OPTION);`
``

`Interpolation_T *interp_Gtilda  = init_interpolation();`
`Interpolation_T *interp_dGtilda = init_interpolation();`
``
`interp_Gtilda->field  = Gtilda_rf;`
`interp_dGtilda->field = dGtilda_rf;`
``
`interp_Gtilda->X = X[0];`
`interp_Gtilda->Y = X[1];`
`interp_Gtilda->Z = X[2];`
`interp_Gtilda->XYZ_dir_flag = 1;`
``
`interp_dGtilda->X = X[0];`
`interp_dGtilda->Y = X[1];`
`interp_dGtilda->Z = X[2];`
`interp_dGtilda->XYZ_dir_flag = 1;`
``
`plan_interpolation(interp_Gtilda);`
`plan_interpolation(interp_dGtilda);`
`const double gt  = execute_interpolation(interp_Gtilda);`
`const double dgt = execute_interpolation(interp_dGtilda);`
``
`free_interpolation(interp_Gtilda);`
`free_interpolation(interp_dGtilda);`
``
`const double f = dgt/gt+2*dLnGamma;`
`assert(isfinite(f));` # if f goes banana
``
`REMOVE_FIELD(Gtilda_rf);`
`REMOVE_FIELD(dGtilda_rf);`

`return f;`
`}`
