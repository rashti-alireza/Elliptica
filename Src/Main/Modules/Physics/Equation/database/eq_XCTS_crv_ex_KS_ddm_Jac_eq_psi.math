# psi (conformal factor) Jacobian equation:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

# C macors
C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = JACOBIAN_DERIVATIVE(name);

# C arguments for jacobian of derivative
C_arg = (j_name,ijk,lmn);
C_arg2 = [ijk == lmn]; # for kd

# main function:
`#include "eq_header.h"`;
`#include "maths_equation_solvings_lib.h"`;
`void *eq_XCTS_curve_exc_KS_ddm_jacobian_eq_psi(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES OR DEFINES THE FOLLOWING VARIABLES:
# patch, S, B, E_Trans, node, Ni, Nj, K0, Nk, i,j,k
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_JACOBIAN_EQ_DECLARE`;
`  Uint ijk,lmn;/* for Jacobian entries J[ijk][lmn] */`;
`  const double kd[2] = {0.,1.};/* Kronecker delta */`;

# declare for cpi
Declare = 
{
  
 # Kroneker delta
 (obj = field, name = kd, rank = 0, none,C_arg2); 

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # Ricci
 (obj = Field,name = trRicciConf, rank = 0, C_macro);

 # trKij
 (obj = Field,name = trK, rank = 0, C_macro);

 # _A_{ij}*_A^{ij}
 (obj = Field,name = _Aij2, rank = 0, C_macro);

 # total conformal energy density
 (obj = Field,name = EConf, rank = 0, C_macro);

 # conformal metric inverse
 (obj = Field,name = igConf, rank = UU, C_macro);

 # conformal connections
 (obj = Field,name = ChrisConf, rank = UDD, C_macro);

 # jacobian derivative 1st order :
 (obj = Field,name = Jpsi, rank = D, C_macro3,C_arg);

 # jacobian derivative 2nd order :
 (obj = Field,name = JJpsi, rank = DD, C_macro3,C_arg);

}

# symmetries for cpi
Symm[igConf(i,j)   = igConf(j,i)];
Symm[ChrisConf(i,j,k)  = ChrisConf(i,k,j)];
Symm[JJpsi(i,j)   = JJpsi(j,i)];

##########################################################################
#    NOTE1: There are different calculation parts, in each part use 
# different names for new variables.
#
#    NOTE2: In Schur domain decomposition method we need two types of
# matrices for Jacobian of Newton-Raphson scheme, matrix B and matrix E. 
# Let's say Jx = -F in Newton-Raphson scheme; then,
# B[i][j] = d[F(f(ijk))]/df(lmn), where i = map[ijk], and j = map[lmn] and
# ijk takes their values ON INNER POINTS
# of a patch, namley those collocated points that don't reach boundary of
# the patch, and lmn runs over ALL BUT the interface points (interface
# points are those located between two patches).
# E[i][j] = d[F(f(ijk))]/df(lmn), where i = map[ijk], and j = map[lmn] and
# ijk takes their values ON INNER POINTS and lmn runs over INTERFACE points.
#
#    PRAGMATICALLY:
# Fill both B matrix and E matrix part WITH THE SAME EQUATION, you just
# need to write two duplicated equations for each part, 
# and if you're using interim variables use different names for each part.
#
#    NOTE3: For each part which doesn't exist, let it be 0.
##########################################################################


###############################################
####### B matrix: J[ijk][lmn] in Jx = -F ###### 
###############################################
`  DDM_SCHUR_JACOBIAN_EQ_Bpart_OPEN\n`;

psi4_B = psi**4;
aij2_B = _Aij2/psi4_B;

# with AConfIJ^2 and  trRicciConf :
Bpart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
 -kd*(\
       trRicciConf/8 + 5*psi4_B*(trK**2)/12 + (7/8)*aij2_B/psi4_B + 2*pi*EConf*(psi**-2)\
     );

# with AConfIJ^2 and no trRicciConf:
#Bpart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
# -kd*(\
#       5*psi4_B*(trK**2)/12 + (7/8)*aij2_B/psi4_B + 2*pi*EConf*(psi**-2)\
#     );

# no AConfIJ^2 and no adjsustment for trRicciConf sign:
# Bpart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
# -kd*(\
#       trRicciConf/8 + 5*psi4_B*(trK**2)/12 + 2*pi*EConf*(psi**-2)\
#     );

`  B[i][j] = Bpart;\n`;
`  DDM_SCHUR_JACOBIAN_EQ_Bpart_CLOSE\n`;
###############################################


###############################################
###### E matrix: J[ijk][lmn] in Jx = -F #######
###############################################
`  DDM_SCHUR_JACOBIAN_EQ_Epart_OPEN\n`;

psi4_E = psi**4;
aij2_E = _Aij2/psi4_E;

# with AConfIJ^2 and trRicciConf:
Epart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
-kd*(\
       trRicciConf/8 + 5*psi4_E*(trK**2)/12 + (7/8)*aij2_E/psi4_E + 2*pi*EConf*(psi**-2)\
     );

# with AConfIJ^2 and no trRicciConf:
# Epart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
# -kd*(\
#        5*psi4_E*(trK**2)/12 + (7/8)*aij2_E/psi4_E + 2*pi*EConf*(psi**-2)\
#     );

# no AConfIJ^2 and no adjsustment for trRicciConf sign:
# Epart =  igConf(i,j)*JJpsi(-i,-j) - igConf(-i,-j)*ChrisConf(l,i,j)*Jpsi(-l)\
# -kd*(\
#       trRicciConf/8 + 5*psi4_E*(trK**2)/12 + 2*pi*EConf*(psi**-2)\
#     );


`  E_Trans[j][i] = Epart;\n`;
`  DDM_SCHUR_JACOBIAN_EQ_Epart_CLOSE\n`;
###############################################

`  return 0;`;
`}`;

