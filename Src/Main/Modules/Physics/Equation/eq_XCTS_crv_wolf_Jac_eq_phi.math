# Jacobian equation for phi:

# Manifold or grid Dimension
Dimension = 3;

# point on manifold shown by:
Point = ijk;

# C macors
C_macro  = READ_v(name);
C_macro2 = REALLOC_v_WRITE_v(name);
C_macro3 = JACOBIAN_DERIVATIVE(name);

# C arguments for jacobian of derivative
C_arg = (j_name,ijk,lmn);
C_arg2 = [ijk == lmn]; # for kd

# main function:
`#include "eq_header.h"`;
`#include "maths_equation_solvings_lib.h"`;

`void *eq_XCTS_curve_Wolf_ddm_jacobian_eq_phi(void *vp1,void *vp2)\n{`;

# NOTE: THE FOLLOWING MACRO DECLARES OR DEFINES THE FOLLOWING VARIABLES:
# patch, S, B, E_Trans, node, Ni, Nj, K0, Nk, i,j,k
# THUS, DO NOT DEFINE THEM AGAIN.
`  DDM_SCHUR_JACOBIAN_EQ_DECLARE`;
`  Uint ijk,lmn;/* for Jacobian entries J[ijk][lmn] */`;
#`  const double kd[2] = {0.,1.};/* Kronecker delta */`;
``
## define prefix for parameter
`  EQ_Def_Param_Prefix_Char`
`  EQ_Set_Prefix("NS")`
``
# declare for cpi
Declare = 
{
  # Kroneker delta
  #(obj = field, name = kd, rank = 0, none,C_arg2); 

 # Jphi 1st derivative
 (obj = Field,name = Jphi, rank = D, C_macro3,C_arg);

 # JJphi 2nd derivative
 (obj = Field,name = JJphi, rank = DD, C_macro3,C_arg);

 # enthalpy
 (obj = Field,name = enthalpy, rank = 0, C_macro);

 # enthalpy 1st derivative
 (obj = Field,name = denthalpy, rank = D, C_macro);

 # rest mass density
 (obj = Field,name = rho0, rank = 0, C_macro);

 # rest mass density 1st derivative
 (obj = Field,name = drho0, rank = D, C_macro);

 # alphaPsi
 (obj = Field,name = alphaPsi, rank = 0, C_macro);

 # alphaPsi first derivative 
 (obj = Field,name = dalphaPsi, rank = D, C_macro);

 # conformal factor
 (obj = Field,name = psi, rank = 0, C_macro);

 # conformal factor 1st derivative
 (obj = Field,name = dpsi, rank = D, C_macro);

 # conformal metric inverse
 (obj = Field,name = igConf, rank = UU, C_macro);

 # conformal connections
 (obj = Field,name = ChrisConf, rank = UDD, C_macro);

 # rho_center
 (obj = variable,name = rhoc, rank = 0, none);

 # small factor
 (obj = variable,name = e, rank = 0, none);

 # small factor2
 (obj = variable,name = att, rank = 0, none);

}

# symmetries for cpi
Symm[JJphi(i,j)       = JJphi(j,i)];
Symm[igConf(i,j)      = igConf(j,i)];
Symm[ChrisConf(i,j,k) = ChrisConf(i,k,j)];

`  const double rhoc = Pgetd(EQ_PrefixIt("rho_center"));`
`  const double e    = Pgetd(EQ_PrefixIt("phi_polish"));`
`  const double att  = e*rhoc;`

##########################################################################
#    NOTE1: There are different calculation parts, in each part use 
# different names for new variables.
#
#    NOTE2: In Schur domain decomposition method we need two types of
# matrices for Jacobian of Newton-Raphson scheme, matrix B and matrix E. 
# Let's say Jx = -F in Newton-Raphson scheme; then,
# B[i][j] = d[F(f(ijk))]/df(lmn), where i = map[ijk], and j = map[lmn] and
# ijk takes their values ON INNER POINTS
# of a patch, namley those collocated points that don't reach boundary of
# the patch, and lmn runs over ALL BUT the interface points (interface
# points are those located between two patches).
# E[i][j] = d[F(f(ijk))]/df(lmn), where i = map[ijk], and j = map[lmn] and
# ijk takes their values ON INNER POINTS and lmn runs over INTERFACE points.
#
#    PRAGMATICALLY:
# Fill both B matrix and E matrix part WITH THE SAME EQUATION, you just
# need to write two duplicated equations for each part, 
# and if you're using interim variables use different names for each part.
#
#    NOTE3: For each part which doesn't exist, let it be 0.
##########################################################################


###############################################
####### B matrix: J[ijk][lmn] in Jx = -F ###### 
###############################################

`  DDM_SCHUR_JACOBIAN_EQ_Bpart_OPEN\n`;
dLn_of_alpha_b_(i) = dalphaPsi(i)/alphaPsi - dpsi(i)/psi;
#dLn_of_rho0_b(i)  = drho0(i)/rho0;
dLn_of_enthalpy_b_(i)  = denthalpy(i)/enthalpy;
#dLns0_b(i) = dLn_of_alpha_b_(i) + dLn_of_rho0_b(i) - dLn_of_enthalpy_b_(i);
dLns0_b_(i) = drho0(i)+rho0*(dLn_of_alpha_b_(i) - dLn_of_enthalpy_b_(i));

t1_b_ = dLns0_b_(-i)*(psi**-4)*igConf(i,l)*Jphi(-l);
t2_b_ = 2*(psi**-5)*dpsi(-i)*igConf(i,l)*Jphi(-l);
t3_b_ = (psi**-4)*igConf(-i,-l)*(JJphi(i,l)-ChrisConf(n,i,l)*Jphi(-n));

Bpart_ = t1_b_+rho0*(t2_b_+t3_b_)+att*((1-rho0/rhoc)**4)*t3_b_;

`  B[i][j] = Bpart_;\n`;
`  DDM_SCHUR_JACOBIAN_EQ_Bpart_CLOSE\n`;

###############################################
###### E matrix: J[ijk][lmn] in Jx = -F #######
###############################################

`  DDM_SCHUR_JACOBIAN_EQ_Epart_OPEN\n`;
dLn_of_alpha_e_(i) = dalphaPsi(i)/alphaPsi - dpsi(i)/psi;
#dLn_of_rho0_e(i)  = drho0(i)/rho0;
dLn_of_enthalpy_e_(i)  = denthalpy(i)/enthalpy;
#dLns0_e(i) = dLn_of_alpha_e_(i) + dLn_of_rho0_e(i) - dLn_of_enthalpy_e_(i);
dLns0_e_(i) = drho0(i)+rho0*(dLn_of_alpha_e_(i) - dLn_of_enthalpy_e_(i));

t1_e_ = dLns0_e_(-i)*(psi**-4)*igConf(i,l)*Jphi(-l);
t2_e_ = 2*(psi**-5)*dpsi(-i)*igConf(i,l)*Jphi(-l);
t3_e_ = (psi**-4)*igConf(-i,-l)*(JJphi(i,l)-ChrisConf(n,i,l)*Jphi(-n));

Epart_ = t1_e_+rho0*(t2_e_+t3_e_)+att*((1-rho0/rhoc)**4)*t3_e_;

`  E_Trans[j][i] = Epart_;\n`;
`  DDM_SCHUR_JACOBIAN_EQ_Epart_CLOSE\n`;

###############################################

## demanding phi = 0 at the center of NS
`  if(patch->grid->kind != Grid_SplitCubedSpherical_BHNS &&`
`     patch->grid->kind != Grid_SplitCubedSpherical_NSNS &&`
`     patch->grid->kind != Grid_SplitCubedSpherical_SNS)`
`    Error0("For this grid you need to figure out where to set phi = 0.\n");`
``
`  if(IsItCovering(patch,"central_box"))`
`  {`
`    const double Att_Con_Num = 1E-5;`
`    const double NS_center[3] = {Pgetd(EQ_PrefixIt("center_x")),`
`                                 Pgetd(EQ_PrefixIt("center_y")),`
`                                 Pgetd(EQ_PrefixIt("center_z"))};`
`    double X[3] = {0};`
``
`    if (X_of_x(X,NS_center,patch))`
`    {`
`      fdInterp_dfs_T *const dInterp_df = get_dInterp_df(patch,0,"none");`
`      const Uint nn = patch->nn;`
`      double *d_df = alloc_double(nn);`
`      for (ijk = 0; ijk < nn; ++ijk)`
`        d_df[ijk] = dInterp_df(patch,X,ijk,0);`
``
       ## B part:
`      for (i = 0; i < Ni; ++i)`
`      {`
`        for (j = 0; j < Nj; ++j)`
`        {`
`         lmn = node[j];`
`         B[i][j] += Att_Con_Num*d_df[lmn];` # for eq: phi = 0
`        }`
`      }`
``
       ## E part:
`      if (S->NI)/* if there is any interface points then E is needed */`
`      {`
`        E_Trans = S->E_Trans->reg->A;`
`        for (k = K0; k < Nk; ++k)`
`        {`
`          lmn = node[k];`
`          j = k-K0;`
`          for (i = 0; i < Ni; ++i)`
`          {`
`            E_Trans[j][i] += Att_Con_Num*d_df[lmn];`
`          }`
`        }`
`      }/* end of if (S->NI) */`
`      free(d_df);`
`    }`
`  }`
`  return 0;`;
`}`;

