/*
  These C codes generated by Cpi version 2.0
  Copyright (C) 2019-2021 Alireza Rashti.
*/


#include "star_header.h"

double star_NS_idealfluid_gConf_root_force_bal(void *params,const double *const x);
double star_NS_idealfluid_gConf_root_force_bal(void *params,const double *const x)
{
const struct Force_Balance_RootFinder_S *const par = params;
Patch_T *const patch = par->patch;
const Uint  nn   = patch->nn;
const double *const X = par->X; 
const double dLnGamma = par->dLnGamma;
const int dir         = par->dir;
const double Vr       = par->Vr;
const double D        = par->D;
const double *const V2CM = par->V2CM; 
double Omega = 0, y_CM = 0, x_CM = 0;
Uint ijk;

if(!Pcmps("ADM_B1I_form","inspiral")) Error0(NO_OPTION);

if(par->find_y_CM)
{
  Omega = par->Omega;
  y_CM  = x[0];
  x_CM  = par->x_CM;
}
else if(par->find_x_CM)
{
  Omega = par->Omega;
  y_CM  = par->y_CM;
  x_CM  = x[0];
}
else if(par->find_Omega)
{
  Omega = x[0];
  y_CM  = par->y_CM;
  x_CM  = par->x_CM;
}
else
{
  Error0(NO_OPTION);
}

  /* declaring: */
  READ_v(gConf_D0D2)
  READ_v(gConf_D0D0)
  READ_v(gConf_D0D1)
  READ_v(gConf_D1D2)
  READ_v(gConf_D1D1)
  READ_v(gConf_D2D2)
  READ_v(W_U1)
  READ_v(W_U0)
  READ_v(W_U2)
  READ_v(alphaPsi)
  READ_v(B0_U2)
  READ_v(B0_U1)
  READ_v(B0_U0)
  READ_v(psi)
  READ_v(enthalpy)
  READ_v(u0)


ADD_AND_ALLOC_FIELD(Gtilda_rf);
ADD_FIELD(dGtilda_rf);
DECLARE_FIELD(Gtilda_rf);
DECLARE_FIELD(dGtilda_rf);
for (ijk = 0; ijk < nn; ++ijk)
{
double x0  = patch->node[ijk]->x[0];
double y0  = patch->node[ijk]->x[1];
double B1_U0 = Omega*(-y0+y_CM)+Vr*(x0-x_CM)/D;
double B1_U1 = Omega*(x0-x_CM)+Vr*(y0-y_CM)/D;
double B1_U2 = 0;
  double beta_U1 = 
B0_U1[ijk] + B1_U1;

  double beta_U0 = 
B0_U0[ijk] + B1_U0;

  double beta_U2 = 
B0_U2[ijk] + B1_U2;

  double alpha = 
alphaPsi[ijk]/psi[ijk];

  double alpha2 = 
pow(alpha, 2);

  double psi4 = 
pow(psi[ijk], 4);

  double t_U0 = 
W_U0[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U0;

  double t_U1 = 
W_U1[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U1;

  double t_U2 = 
W_U2[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U2;

  double t2 = 
psi4*(gConf_D0D0[ijk]*pow(t_U0, 2) + 2.0*gConf_D0D1[ijk]*t_U0*t_U1 +
2.0*gConf_D0D2[ijk]*t_U0*t_U2 + gConf_D1D1[ijk]*pow(t_U1, 2) + 2.0*
gConf_D1D2[ijk]*t_U1*t_U2 + gConf_D2D2[ijk]*pow(t_U2, 2));

  double Gtilda = 
alpha2 - t2;


Gtilda_rf->v[ijk] = Gtilda;
}

if (dir == -1)
{
  double *dx_rf = Partial_Derivative(Gtilda_rf,"x");
  double *dy_rf = Partial_Derivative(Gtilda_rf,"y");
  double *const drf = dx_rf;
  for (ijk = 0; ijk < nn; ++ijk)
  {
    drf[ijk] = V2CM[0]*dx_rf[ijk]+V2CM[1]*dy_rf[ijk];
  }
  dGtilda_rf->v = drf;
  dx_rf = 0;
  free(dy_rf);
}
else if (dir == 0)
  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"x");
else if (dir == 1)
  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"y");
else if (dir == 2)
  dGtilda_rf->v  = Partial_Derivative(Gtilda_rf,"z");
else
  Error0(NO_OPTION);

Interpolation_T *interp_Gtilda  = init_interpolation();
Interpolation_T *interp_dGtilda = init_interpolation();

interp_Gtilda->field  = Gtilda_rf;
interp_dGtilda->field = dGtilda_rf;

interp_Gtilda->X = X[0];
interp_Gtilda->Y = X[1];
interp_Gtilda->Z = X[2];
interp_Gtilda->XYZ_dir_flag = 1;

interp_dGtilda->X = X[0];
interp_dGtilda->Y = X[1];
interp_dGtilda->Z = X[2];
interp_dGtilda->XYZ_dir_flag = 1;

plan_interpolation(interp_Gtilda);
plan_interpolation(interp_dGtilda);
const double gt  = execute_interpolation(interp_Gtilda);
const double dgt = execute_interpolation(interp_dGtilda);

free_interpolation(interp_Gtilda);
free_interpolation(interp_dGtilda);

const double f = dgt/gt+2*dLnGamma;
assert(isfinite(f));

REMOVE_FIELD(Gtilda_rf);
REMOVE_FIELD(dGtilda_rf);
return f;
}
