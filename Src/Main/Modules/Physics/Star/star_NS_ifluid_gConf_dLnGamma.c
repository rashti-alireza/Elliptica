/*
  These C codes generated by Cpi version 2.0
  Copyright (C) 2019-2021 Alireza Rashti.
*/


#include "star_header.h"

double star_NS_idealfluid_gConf_dLnGamma_force_bal(Patch_T *const patch,const double *const NS_centerX,const int dir);
double star_NS_idealfluid_gConf_dLnGamma_force_bal(Patch_T *const patch,const double *const NS_centerX,const int dir)
{

  /* declaring: */
  READ_v(gConf_D0D2)
  READ_v(gConf_D0D0)
  READ_v(gConf_D0D1)
  READ_v(gConf_D1D2)
  READ_v(gConf_D1D1)
  READ_v(gConf_D2D2)
  READ_v(W_U1)
  READ_v(W_U0)
  READ_v(W_U2)
  READ_v(dphi_D2)
  READ_v(dphi_D1)
  READ_v(dphi_D0)
  READ_v(alphaPsi)
  READ_v(beta_U1)
  READ_v(beta_U0)
  READ_v(beta_U2)
  READ_v(psi)
  READ_v(enthalpy)
  READ_v(u0)


ADD_AND_ALLOC_FIELD(GAMMA_fb);
ADD_FIELD(dGAMMA_fb);
DECLARE_FIELD(GAMMA_fb);
DECLARE_FIELD(dGAMMA_fb);
const Uint nn = patch->nn;
Uint ijk;
for (ijk = 0; ijk < nn; ++ijk)
{
  double alpha = 
alphaPsi[ijk]/psi[ijk];

  double alpha2 = 
pow(alpha, 2);

  double psi4 = 
pow(psi[ijk], 4);

  double t_U0 = 
W_U0[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U0[ijk];

  double t_U1 = 
W_U1[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U1[ijk];

  double t_U2 = 
W_U2[ijk]/(enthalpy[ijk]*u0[ijk]) + beta_U2[ijk];

  double t2 = 
psi4*(gConf_D0D0[ijk]*pow(t_U0, 2) + 2.0*gConf_D0D1[ijk]*t_U0*t_U1 +
2.0*gConf_D0D2[ijk]*t_U0*t_U2 + gConf_D1D1[ijk]*pow(t_U1, 2) + 2.0*
gConf_D1D2[ijk]*t_U1*t_U2 + gConf_D2D2[ijk]*pow(t_U2, 2));

  double v = 
(dphi_D0[ijk]*t_U0 + dphi_D1[ijk]*t_U1 + dphi_D2[ijk]*t_U2)/(alpha2*
enthalpy[ijk]*u0[ijk]) + psi4*(pow(W_U0[ijk], 2)*gConf_D0D0[ijk] + 2.0*
W_U0[ijk]*W_U1[ijk]*gConf_D0D1[ijk] + 2.0*W_U0[ijk]*W_U2[ijk]*
gConf_D0D2[ijk] + pow(W_U1[ijk], 2)*gConf_D1D1[ijk] + 2.0*W_U1[ijk]*
W_U2[ijk]*gConf_D1D2[ijk] + pow(W_U2[ijk], 2)*gConf_D2D2[ijk])/
(pow(alpha, 2)*pow(enthalpy[ijk], 2)*pow(u0[ijk], 2));

  double G = 
-alpha*u0[ijk]*pow((alpha2 - t2)/alpha2, -0.5)*(v - 1);


GAMMA_fb->v[ijk]  = G;
}
if (dir == 0)
  dGAMMA_fb->v  = Partial_Derivative(GAMMA_fb,"x");
else if (dir == 1)
  dGAMMA_fb->v  = Partial_Derivative(GAMMA_fb,"y");
else if (dir == 2)
  dGAMMA_fb->v  = Partial_Derivative(GAMMA_fb,"z");
else
  Error0(NO_OPTION);

Interpolation_T *interp_GAMMA   = init_interpolation();
Interpolation_T *interp_dGAMMA  = init_interpolation();

interp_GAMMA->field   = GAMMA_fb;
interp_dGAMMA->field  = dGAMMA_fb;

interp_GAMMA->X = NS_centerX[0];
interp_GAMMA->Y = NS_centerX[1];
interp_GAMMA->Z = NS_centerX[2];
interp_GAMMA->XYZ_dir_flag = 1;

interp_dGAMMA->X = NS_centerX[0];
interp_dGAMMA->Y = NS_centerX[1];
interp_dGAMMA->Z = NS_centerX[2];
interp_dGAMMA->XYZ_dir_flag = 1;

plan_interpolation(interp_GAMMA);
plan_interpolation(interp_dGAMMA);

const double g  = execute_interpolation(interp_GAMMA);
const double dg = execute_interpolation(interp_dGAMMA);
const double f  = dg/g;
if(!isfinite(f))
{
  Error0("Force balance equation was failed.\n");
}

REMOVE_FIELD(GAMMA_fb);
REMOVE_FIELD(dGAMMA_fb);
free_interpolation(interp_GAMMA);
free_interpolation(interp_dGAMMA);

return f;
}
